// Package uisvc provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package uisvc

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/pkg/errors"
)

const (
	SessionScopes = "session.Scopes"
	TokenScopes   = "token.Scopes"
)

// Error defines model for Error.
type Error struct {
	Errors *[]string `json:"errors,omitempty"`
	Log    *bool     `json:"log,omitempty"`
}

// ModelSubmission defines model for ModelSubmission.
type ModelSubmission struct {
	BaseRef    *Ref       `json:"base_ref,omitempty"`
	Canceled   *bool      `json:"canceled,omitempty"`
	CreatedAt  *time.Time `json:"created_at,omitempty"`
	FinishedAt *time.Time `json:"finished_at"`
	HeadRef    *Ref       `json:"head_ref,omitempty"`
	Id         *int64     `json:"id,omitempty"`
	RunsCount  *int64     `json:"runs_count,omitempty"`
	StartedAt  *time.Time `json:"started_at"`
	Status     *bool      `json:"status"`
	TasksCount *int64     `json:"tasks_count,omitempty"`
	TicketId   *int64     `json:"ticket_id,omitempty"`
	User       *User      `json:"user,omitempty"`
}

// ModelSubmissionList defines model for ModelSubmissionList.
type ModelSubmissionList []ModelSubmission

// Ref defines model for Ref.
type Ref struct {
	Id         *int64      `json:"id,omitempty"`
	RefName    *string     `json:"ref_name,omitempty"`
	Repository *Repository `json:"repository,omitempty"`
	Sha        *string     `json:"sha,omitempty"`
}

// RepoConfig defines model for RepoConfig.
type RepoConfig struct {
	GlobalTimeout   *int64  `json:"global_timeout,omitempty"`
	OverrideQueue   *bool   `json:"override_queue,omitempty"`
	OverrideTimeout *bool   `json:"override_timeout,omitempty"`
	Queue           *string `json:"queue,omitempty"`
	Workdir         *string `json:"workdir,omitempty"`
}

// Repository defines model for Repository.
type Repository struct {
	AutoCreated *bool              `json:"auto_created,omitempty"`
	Disabled    *bool              `json:"disabled,omitempty"`
	Github      *Repository_Github `json:"github,omitempty"`
	Id          *int64             `json:"id,omitempty"`
	Name        *string            `json:"name,omitempty"`
	Private     *bool              `json:"private,omitempty"`
}

// Repository_Github defines model for Repository.Github.
type Repository_Github struct {
	AdditionalProperties map[string]interface{} `json:"-"`
}

// RepositoryList defines model for RepositoryList.
type RepositoryList []Repository

// Resources defines model for Resources.
type Resources struct {
	Cpu    *string `json:"cpu,omitempty"`
	Disk   *string `json:"disk,omitempty"`
	Iops   *string `json:"iops,omitempty"`
	Memory *string `json:"memory,omitempty"`
}

// Run defines model for Run.
type Run struct {
	CreatedAt  *time.Time   `json:"created_at,omitempty"`
	FinishedAt *time.Time   `json:"finished_at"`
	Id         *int64       `json:"id,omitempty"`
	Name       *string      `json:"name,omitempty"`
	RanOn      *string      `json:"ran_on"`
	Settings   *RunSettings `json:"settings,omitempty"`
	StartedAt  *time.Time   `json:"started_at"`
	Status     *bool        `json:"status"`
	Task       *Task        `json:"task,omitempty"`
}

// RunList defines model for RunList.
type RunList []Run

// RunSettings defines model for RunSettings.
type RunSettings struct {
	Command   *[]string             `json:"command,omitempty"`
	Image     *string               `json:"image,omitempty"`
	Metadata  *RunSettings_Metadata `json:"metadata,omitempty"`
	Name      *string               `json:"name,omitempty"`
	Queue     *string               `json:"queue,omitempty"`
	Resources *Resources            `json:"resources,omitempty"`
	Timeout   *int64                `json:"timeout,omitempty"`
}

// RunSettings_Metadata defines model for RunSettings.Metadata.
type RunSettings_Metadata struct {
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Task defines model for Task.
type Task struct {
	Canceled   *bool            `json:"canceled,omitempty"`
	CreatedAt  *time.Time       `json:"created_at,omitempty"`
	FinishedAt *time.Time       `json:"finished_at"`
	Id         *int64           `json:"id,omitempty"`
	Path       *string          `json:"path,omitempty"`
	Runs       *int64           `json:"runs,omitempty"`
	Settings   *TaskSettings    `json:"settings,omitempty"`
	StartedAt  *time.Time       `json:"started_at"`
	Status     *bool            `json:"status"`
	Submission *ModelSubmission `json:"submission,omitempty"`
}

// TaskList defines model for TaskList.
type TaskList []Task

// TaskSettings defines model for TaskSettings.
type TaskSettings struct {
	Config           *RepoConfig `json:"config,omitempty"`
	DefaultImage     *string     `json:"default_image,omitempty"`
	DefaultQueue     *string     `json:"default_queue,omitempty"`
	DefaultResources *Resources  `json:"default_resources,omitempty"`

	// the default timeout; in nanoseconds
	DefaultTimeout *int64                  `json:"default_timeout,omitempty"`
	Env            *[]string               `json:"env,omitempty"`
	Metadata       *map[string]interface{} `json:"metadata,omitempty"`
	Mountpoint     *string                 `json:"mountpoint,omitempty"`
	Runs           *TaskSettings_Runs      `json:"runs,omitempty"`
	Workdir        *string                 `json:"workdir,omitempty"`
}

// TaskSettings_Runs defines model for TaskSettings.Runs.
type TaskSettings_Runs struct {
	AdditionalProperties map[string]RunSettings `json:"-"`
}

// User defines model for User.
type User struct {
	Errors           *[]UserError `json:"errors,omitempty"`
	Id               *int64       `json:"id,omitempty"`
	LastScannedRepos *time.Time   `json:"last_scanned_repos"`
	Token            *User_Token  `json:"token,omitempty"`
	Username         *string      `json:"username,omitempty"`
}

// User_Token defines model for User.Token.
type User_Token struct {
	AdditionalProperties map[string]interface{} `json:"-"`
}

// UserError defines model for UserError.
type UserError struct {
	Error *string `json:"error,omitempty"`
	Id    *int64  `json:"id,omitempty"`
}

// GetLoginParams defines parameters for GetLogin.
type GetLoginParams struct {

	// The code github sent back to us with the callback, we use it in the OAuth2 exchange to validate the request.
	Code string `json:"code"`

	// The state (randomized string) we sent with the original link; this is echoed back to us so we can further identify the user.
	State string `json:"state"`
}

// GetRepositoriesMyParams defines parameters for GetRepositoriesMy.
type GetRepositoriesMyParams struct {

	// search string by which to filter results
	Search *string `json:"search,omitempty"`
}

// GetRepositoriesSubscribedParams defines parameters for GetRepositoriesSubscribed.
type GetRepositoriesSubscribedParams struct {

	// search string by which to filter results
	Search *string `json:"search,omitempty"`
}

// GetRepositoriesVisibleParams defines parameters for GetRepositoriesVisible.
type GetRepositoriesVisibleParams struct {

	// search string by which to filter results
	Search *string `json:"search,omitempty"`
}

// GetRunsParams defines parameters for GetRuns.
type GetRunsParams struct {

	// pagination control: what page to retrieve in the query.
	Page *int64 `json:"page,omitempty"`

	// pagination control: how many items counts as a page.
	PerPage *int64 `json:"perPage,omitempty"`

	// optional; the repository name to get the tasks for.
	Repository *string `json:"repository,omitempty"`

	// optional; the sha to get the tasks for.
	Sha *string `json:"sha,omitempty"`
}

// GetRunsCountParams defines parameters for GetRunsCount.
type GetRunsCountParams struct {
	Repository *string `json:"repository,omitempty"`
	Sha        *string `json:"sha,omitempty"`
}

// GetSubmissionIdRunsParams defines parameters for GetSubmissionIdRuns.
type GetSubmissionIdRunsParams struct {

	// pagination control: what page to retrieve in the query.
	Page *int64 `json:"page,omitempty"`

	// pagination control: how many items counts as a page.
	PerPage *int64 `json:"perPage,omitempty"`
}

// GetSubmissionIdTasksParams defines parameters for GetSubmissionIdTasks.
type GetSubmissionIdTasksParams struct {

	// pagination control: what page to retrieve in the query.
	Page *int64 `json:"page,omitempty"`

	// pagination control: how many items counts as a page.
	PerPage *int64 `json:"perPage,omitempty"`
}

// GetSubmissionsParams defines parameters for GetSubmissions.
type GetSubmissionsParams struct {

	// pagination control: what page to retrieve in the query.
	Page *int64 `json:"page,omitempty"`

	// pagination control: how many items counts as a page.
	PerPage *int64 `json:"perPage,omitempty"`

	// the repository owner/repo to be viewed.
	Repository *string `json:"repository,omitempty"`

	// the sha or branch to be viewed.
	Sha *string `json:"sha,omitempty"`
}

// GetSubmissionsCountParams defines parameters for GetSubmissionsCount.
type GetSubmissionsCountParams struct {

	// the repository owner/repo to be viewed.
	Repository *string `json:"repository,omitempty"`

	// the sha or branch to be viewed.
	Sha *string `json:"sha,omitempty"`
}

// GetSubmitParams defines parameters for GetSubmit.
type GetSubmitParams struct {

	// the repository owner/repo to be tested.
	Repository string `json:"repository"`

	// the sha or branch to be tested
	Sha string `json:"sha"`

	// Run all tests instead of relying on diff selection to pick them.
	All *bool `json:"all,omitempty"`
}

// GetTasksParams defines parameters for GetTasks.
type GetTasksParams struct {

	// pagination control: what page to retrieve in the query.
	Page *int64 `json:"page,omitempty"`

	// pagination control: how many items counts as a page.
	PerPage *int64 `json:"perPage,omitempty"`

	// optional; the repository name to get the tasks for.
	Repository *string `json:"repository,omitempty"`

	// optional; the sha to get the tasks for.
	Sha *string `json:"sha,omitempty"`
}

// GetTasksCountParams defines parameters for GetTasksCount.
type GetTasksCountParams struct {

	// optional; repository for filtering
	Repository *string `json:"repository,omitempty"`

	// optional; sha for filtering
	Sha *string `json:"sha,omitempty"`
}

// GetTasksRunsIdParams defines parameters for GetTasksRunsId.
type GetTasksRunsIdParams struct {

	// pagination control: what page to retrieve in the query.
	Page *int64 `json:"page,omitempty"`

	// pagination control: how many items counts as a page.
	PerPage *int64 `json:"perPage,omitempty"`
}

// GetTasksSubscribedParams defines parameters for GetTasksSubscribed.
type GetTasksSubscribedParams struct {

	// pagination control: what page to retrieve in the query.
	Page *int64 `json:"page,omitempty"`

	// pagination control: how many items counts as a page.
	PerPage *int64 `json:"perPage,omitempty"`
}

// Getter for additional properties for Repository_Github. Returns the specified
// element and whether it was found
func (a Repository_Github) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Repository_Github
func (a *Repository_Github) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Repository_Github to handle AdditionalProperties
func (a *Repository_Github) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Repository_Github to handle AdditionalProperties
func (a Repository_Github) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RunSettings_Metadata. Returns the specified
// element and whether it was found
func (a RunSettings_Metadata) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RunSettings_Metadata
func (a *RunSettings_Metadata) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RunSettings_Metadata to handle AdditionalProperties
func (a *RunSettings_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RunSettings_Metadata to handle AdditionalProperties
func (a RunSettings_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for TaskSettings_Runs. Returns the specified
// element and whether it was found
func (a TaskSettings_Runs) Get(fieldName string) (value RunSettings, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for TaskSettings_Runs
func (a *TaskSettings_Runs) Set(fieldName string, value RunSettings) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]RunSettings)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for TaskSettings_Runs to handle AdditionalProperties
func (a *TaskSettings_Runs) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]RunSettings)
		for fieldName, fieldBuf := range object {
			var fieldVal RunSettings
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for TaskSettings_Runs to handle AdditionalProperties
func (a TaskSettings_Runs) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for User_Token. Returns the specified
// element and whether it was found
func (a User_Token) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for User_Token
func (a *User_Token) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for User_Token to handle AdditionalProperties
func (a *User_Token) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for User_Token to handle AdditionalProperties
func (a User_Token) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// PostCancelRunId request
	PostCancelRunId(ctx context.Context, runId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCapabilitiesUsernameCapability request
	DeleteCapabilitiesUsernameCapability(ctx context.Context, username string, capability string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCapabilitiesUsernameCapability request
	PostCapabilitiesUsernameCapability(ctx context.Context, username string, capability string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetErrors request
	GetErrors(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogAttachId request
	GetLogAttachId(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLoggedin request
	GetLoggedin(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogin request
	GetLogin(ctx context.Context, params *GetLoginParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLoginUpgrade request
	GetLoginUpgrade(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogout request
	GetLogout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRepositoriesCiAddOwnerRepo request
	GetRepositoriesCiAddOwnerRepo(ctx context.Context, owner string, repo string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRepositoriesCiDelOwnerRepo request
	GetRepositoriesCiDelOwnerRepo(ctx context.Context, owner string, repo string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRepositoriesMy request
	GetRepositoriesMy(ctx context.Context, params *GetRepositoriesMyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRepositoriesScan request
	GetRepositoriesScan(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRepositoriesSubAddOwnerRepo request
	GetRepositoriesSubAddOwnerRepo(ctx context.Context, owner string, repo string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRepositoriesSubDelOwnerRepo request
	GetRepositoriesSubDelOwnerRepo(ctx context.Context, owner string, repo string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRepositoriesSubscribed request
	GetRepositoriesSubscribed(ctx context.Context, params *GetRepositoriesSubscribedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRepositoriesVisible request
	GetRepositoriesVisible(ctx context.Context, params *GetRepositoriesVisibleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRunRunId request
	GetRunRunId(ctx context.Context, runId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRuns request
	GetRuns(ctx context.Context, params *GetRunsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRunsCount request
	GetRunsCount(ctx context.Context, params *GetRunsCountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubmissionId request
	GetSubmissionId(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSubmissionIdCancel request
	PostSubmissionIdCancel(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubmissionIdRuns request
	GetSubmissionIdRuns(ctx context.Context, id int64, params *GetSubmissionIdRunsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubmissionIdTasks request
	GetSubmissionIdTasks(ctx context.Context, id int64, params *GetSubmissionIdTasksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubmissions request
	GetSubmissions(ctx context.Context, params *GetSubmissionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubmissionsCount request
	GetSubmissionsCount(ctx context.Context, params *GetSubmissionsCountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubmit request
	GetSubmit(ctx context.Context, params *GetSubmitParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTasks request
	GetTasks(ctx context.Context, params *GetTasksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostTasksCancelId request
	PostTasksCancelId(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTasksCount request
	GetTasksCount(ctx context.Context, params *GetTasksCountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTasksRunsId request
	GetTasksRunsId(ctx context.Context, id int64, params *GetTasksRunsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTasksRunsIdCount request
	GetTasksRunsIdCount(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTasksSubscribed request
	GetTasksSubscribed(ctx context.Context, params *GetTasksSubscribedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteToken request
	DeleteToken(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetToken request
	GetToken(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserProperties request
	GetUserProperties(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) PostCancelRunId(ctx context.Context, runId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCancelRunIdRequest(c.Server, runId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCapabilitiesUsernameCapability(ctx context.Context, username string, capability string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCapabilitiesUsernameCapabilityRequest(c.Server, username, capability)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCapabilitiesUsernameCapability(ctx context.Context, username string, capability string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCapabilitiesUsernameCapabilityRequest(c.Server, username, capability)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetErrors(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetErrorsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogAttachId(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogAttachIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLoggedin(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLoggedinRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogin(ctx context.Context, params *GetLoginParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLoginRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLoginUpgrade(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLoginUpgradeRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogoutRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRepositoriesCiAddOwnerRepo(ctx context.Context, owner string, repo string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRepositoriesCiAddOwnerRepoRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRepositoriesCiDelOwnerRepo(ctx context.Context, owner string, repo string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRepositoriesCiDelOwnerRepoRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRepositoriesMy(ctx context.Context, params *GetRepositoriesMyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRepositoriesMyRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRepositoriesScan(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRepositoriesScanRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRepositoriesSubAddOwnerRepo(ctx context.Context, owner string, repo string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRepositoriesSubAddOwnerRepoRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRepositoriesSubDelOwnerRepo(ctx context.Context, owner string, repo string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRepositoriesSubDelOwnerRepoRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRepositoriesSubscribed(ctx context.Context, params *GetRepositoriesSubscribedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRepositoriesSubscribedRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRepositoriesVisible(ctx context.Context, params *GetRepositoriesVisibleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRepositoriesVisibleRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRunRunId(ctx context.Context, runId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRunRunIdRequest(c.Server, runId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRuns(ctx context.Context, params *GetRunsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRunsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRunsCount(ctx context.Context, params *GetRunsCountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRunsCountRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubmissionId(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubmissionIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSubmissionIdCancel(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSubmissionIdCancelRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubmissionIdRuns(ctx context.Context, id int64, params *GetSubmissionIdRunsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubmissionIdRunsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubmissionIdTasks(ctx context.Context, id int64, params *GetSubmissionIdTasksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubmissionIdTasksRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubmissions(ctx context.Context, params *GetSubmissionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubmissionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubmissionsCount(ctx context.Context, params *GetSubmissionsCountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubmissionsCountRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubmit(ctx context.Context, params *GetSubmitParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubmitRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTasks(ctx context.Context, params *GetTasksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTasksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTasksCancelId(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTasksCancelIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTasksCount(ctx context.Context, params *GetTasksCountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTasksCountRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTasksRunsId(ctx context.Context, id int64, params *GetTasksRunsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTasksRunsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTasksRunsIdCount(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTasksRunsIdCountRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTasksSubscribed(ctx context.Context, params *GetTasksSubscribedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTasksSubscribedRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteToken(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTokenRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetToken(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTokenRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserProperties(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserPropertiesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewPostCancelRunIdRequest generates requests for PostCancelRunId
func NewPostCancelRunIdRequest(server string, runId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cancel/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteCapabilitiesUsernameCapabilityRequest generates requests for DeleteCapabilitiesUsernameCapability
func NewDeleteCapabilitiesUsernameCapabilityRequest(server string, username string, capability string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "capability", runtime.ParamLocationPath, capability)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/capabilities/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostCapabilitiesUsernameCapabilityRequest generates requests for PostCapabilitiesUsernameCapability
func NewPostCapabilitiesUsernameCapabilityRequest(server string, username string, capability string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "capability", runtime.ParamLocationPath, capability)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/capabilities/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetErrorsRequest generates requests for GetErrors
func NewGetErrorsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/errors")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLogAttachIdRequest generates requests for GetLogAttachId
func NewGetLogAttachIdRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/log/attach/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLoggedinRequest generates requests for GetLoggedin
func NewGetLoggedinRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/loggedin")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLoginRequest generates requests for GetLogin
func NewGetLoginRequest(server string, params *GetLoginParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/login")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code", runtime.ParamLocationQuery, params.Code); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, params.State); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLoginUpgradeRequest generates requests for GetLoginUpgrade
func NewGetLoginUpgradeRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/login/upgrade")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLogoutRequest generates requests for GetLogout
func NewGetLogoutRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/logout")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRepositoriesCiAddOwnerRepoRequest generates requests for GetRepositoriesCiAddOwnerRepo
func NewGetRepositoriesCiAddOwnerRepoRequest(server string, owner string, repo string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/ci/add/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRepositoriesCiDelOwnerRepoRequest generates requests for GetRepositoriesCiDelOwnerRepo
func NewGetRepositoriesCiDelOwnerRepoRequest(server string, owner string, repo string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/ci/del/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRepositoriesMyRequest generates requests for GetRepositoriesMy
func NewGetRepositoriesMyRequest(server string, params *GetRepositoriesMyParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/my")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Search != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRepositoriesScanRequest generates requests for GetRepositoriesScan
func NewGetRepositoriesScanRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/scan")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRepositoriesSubAddOwnerRepoRequest generates requests for GetRepositoriesSubAddOwnerRepo
func NewGetRepositoriesSubAddOwnerRepoRequest(server string, owner string, repo string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/sub/add/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRepositoriesSubDelOwnerRepoRequest generates requests for GetRepositoriesSubDelOwnerRepo
func NewGetRepositoriesSubDelOwnerRepoRequest(server string, owner string, repo string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/sub/del/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRepositoriesSubscribedRequest generates requests for GetRepositoriesSubscribed
func NewGetRepositoriesSubscribedRequest(server string, params *GetRepositoriesSubscribedParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/subscribed")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Search != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRepositoriesVisibleRequest generates requests for GetRepositoriesVisible
func NewGetRepositoriesVisibleRequest(server string, params *GetRepositoriesVisibleParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/visible")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Search != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRunRunIdRequest generates requests for GetRunRunId
func NewGetRunRunIdRequest(server string, runId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/run/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRunsRequest generates requests for GetRuns
func NewGetRunsRequest(server string, params *GetRunsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/runs")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Repository != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "repository", runtime.ParamLocationQuery, *params.Repository); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sha != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sha", runtime.ParamLocationQuery, *params.Sha); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRunsCountRequest generates requests for GetRunsCount
func NewGetRunsCountRequest(server string, params *GetRunsCountParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/runs/count")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Repository != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "repository", runtime.ParamLocationQuery, *params.Repository); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sha != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sha", runtime.ParamLocationQuery, *params.Sha); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSubmissionIdRequest generates requests for GetSubmissionId
func NewGetSubmissionIdRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/submission/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSubmissionIdCancelRequest generates requests for PostSubmissionIdCancel
func NewPostSubmissionIdCancelRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/submission/%s/cancel", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSubmissionIdRunsRequest generates requests for GetSubmissionIdRuns
func NewGetSubmissionIdRunsRequest(server string, id int64, params *GetSubmissionIdRunsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/submission/%s/runs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSubmissionIdTasksRequest generates requests for GetSubmissionIdTasks
func NewGetSubmissionIdTasksRequest(server string, id int64, params *GetSubmissionIdTasksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/submission/%s/tasks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSubmissionsRequest generates requests for GetSubmissions
func NewGetSubmissionsRequest(server string, params *GetSubmissionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/submissions")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Repository != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "repository", runtime.ParamLocationQuery, *params.Repository); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sha != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sha", runtime.ParamLocationQuery, *params.Sha); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSubmissionsCountRequest generates requests for GetSubmissionsCount
func NewGetSubmissionsCountRequest(server string, params *GetSubmissionsCountParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/submissions/count")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Repository != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "repository", runtime.ParamLocationQuery, *params.Repository); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sha != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sha", runtime.ParamLocationQuery, *params.Sha); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSubmitRequest generates requests for GetSubmit
func NewGetSubmitRequest(server string, params *GetSubmitParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/submit")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "repository", runtime.ParamLocationQuery, params.Repository); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sha", runtime.ParamLocationQuery, params.Sha); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.All != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "all", runtime.ParamLocationQuery, *params.All); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTasksRequest generates requests for GetTasks
func NewGetTasksRequest(server string, params *GetTasksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tasks")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Repository != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "repository", runtime.ParamLocationQuery, *params.Repository); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sha != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sha", runtime.ParamLocationQuery, *params.Sha); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostTasksCancelIdRequest generates requests for PostTasksCancelId
func NewPostTasksCancelIdRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tasks/cancel/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTasksCountRequest generates requests for GetTasksCount
func NewGetTasksCountRequest(server string, params *GetTasksCountParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tasks/count")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Repository != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "repository", runtime.ParamLocationQuery, *params.Repository); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sha != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sha", runtime.ParamLocationQuery, *params.Sha); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTasksRunsIdRequest generates requests for GetTasksRunsId
func NewGetTasksRunsIdRequest(server string, id int64, params *GetTasksRunsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tasks/runs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTasksRunsIdCountRequest generates requests for GetTasksRunsIdCount
func NewGetTasksRunsIdCountRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tasks/runs/%s/count", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTasksSubscribedRequest generates requests for GetTasksSubscribed
func NewGetTasksSubscribedRequest(server string, params *GetTasksSubscribedParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tasks/subscribed")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteTokenRequest generates requests for DeleteToken
func NewDeleteTokenRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/token")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTokenRequest generates requests for GetToken
func NewGetTokenRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/token")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserPropertiesRequest generates requests for GetUserProperties
func NewGetUserPropertiesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/properties")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// PostCancelRunId request
	PostCancelRunIdWithResponse(ctx context.Context, runId int64, reqEditors ...RequestEditorFn) (*PostCancelRunIdResponse, error)

	// DeleteCapabilitiesUsernameCapability request
	DeleteCapabilitiesUsernameCapabilityWithResponse(ctx context.Context, username string, capability string, reqEditors ...RequestEditorFn) (*DeleteCapabilitiesUsernameCapabilityResponse, error)

	// PostCapabilitiesUsernameCapability request
	PostCapabilitiesUsernameCapabilityWithResponse(ctx context.Context, username string, capability string, reqEditors ...RequestEditorFn) (*PostCapabilitiesUsernameCapabilityResponse, error)

	// GetErrors request
	GetErrorsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetErrorsResponse, error)

	// GetLogAttachId request
	GetLogAttachIdWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetLogAttachIdResponse, error)

	// GetLoggedin request
	GetLoggedinWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLoggedinResponse, error)

	// GetLogin request
	GetLoginWithResponse(ctx context.Context, params *GetLoginParams, reqEditors ...RequestEditorFn) (*GetLoginResponse, error)

	// GetLoginUpgrade request
	GetLoginUpgradeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLoginUpgradeResponse, error)

	// GetLogout request
	GetLogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLogoutResponse, error)

	// GetRepositoriesCiAddOwnerRepo request
	GetRepositoriesCiAddOwnerRepoWithResponse(ctx context.Context, owner string, repo string, reqEditors ...RequestEditorFn) (*GetRepositoriesCiAddOwnerRepoResponse, error)

	// GetRepositoriesCiDelOwnerRepo request
	GetRepositoriesCiDelOwnerRepoWithResponse(ctx context.Context, owner string, repo string, reqEditors ...RequestEditorFn) (*GetRepositoriesCiDelOwnerRepoResponse, error)

	// GetRepositoriesMy request
	GetRepositoriesMyWithResponse(ctx context.Context, params *GetRepositoriesMyParams, reqEditors ...RequestEditorFn) (*GetRepositoriesMyResponse, error)

	// GetRepositoriesScan request
	GetRepositoriesScanWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRepositoriesScanResponse, error)

	// GetRepositoriesSubAddOwnerRepo request
	GetRepositoriesSubAddOwnerRepoWithResponse(ctx context.Context, owner string, repo string, reqEditors ...RequestEditorFn) (*GetRepositoriesSubAddOwnerRepoResponse, error)

	// GetRepositoriesSubDelOwnerRepo request
	GetRepositoriesSubDelOwnerRepoWithResponse(ctx context.Context, owner string, repo string, reqEditors ...RequestEditorFn) (*GetRepositoriesSubDelOwnerRepoResponse, error)

	// GetRepositoriesSubscribed request
	GetRepositoriesSubscribedWithResponse(ctx context.Context, params *GetRepositoriesSubscribedParams, reqEditors ...RequestEditorFn) (*GetRepositoriesSubscribedResponse, error)

	// GetRepositoriesVisible request
	GetRepositoriesVisibleWithResponse(ctx context.Context, params *GetRepositoriesVisibleParams, reqEditors ...RequestEditorFn) (*GetRepositoriesVisibleResponse, error)

	// GetRunRunId request
	GetRunRunIdWithResponse(ctx context.Context, runId int64, reqEditors ...RequestEditorFn) (*GetRunRunIdResponse, error)

	// GetRuns request
	GetRunsWithResponse(ctx context.Context, params *GetRunsParams, reqEditors ...RequestEditorFn) (*GetRunsResponse, error)

	// GetRunsCount request
	GetRunsCountWithResponse(ctx context.Context, params *GetRunsCountParams, reqEditors ...RequestEditorFn) (*GetRunsCountResponse, error)

	// GetSubmissionId request
	GetSubmissionIdWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetSubmissionIdResponse, error)

	// PostSubmissionIdCancel request
	PostSubmissionIdCancelWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*PostSubmissionIdCancelResponse, error)

	// GetSubmissionIdRuns request
	GetSubmissionIdRunsWithResponse(ctx context.Context, id int64, params *GetSubmissionIdRunsParams, reqEditors ...RequestEditorFn) (*GetSubmissionIdRunsResponse, error)

	// GetSubmissionIdTasks request
	GetSubmissionIdTasksWithResponse(ctx context.Context, id int64, params *GetSubmissionIdTasksParams, reqEditors ...RequestEditorFn) (*GetSubmissionIdTasksResponse, error)

	// GetSubmissions request
	GetSubmissionsWithResponse(ctx context.Context, params *GetSubmissionsParams, reqEditors ...RequestEditorFn) (*GetSubmissionsResponse, error)

	// GetSubmissionsCount request
	GetSubmissionsCountWithResponse(ctx context.Context, params *GetSubmissionsCountParams, reqEditors ...RequestEditorFn) (*GetSubmissionsCountResponse, error)

	// GetSubmit request
	GetSubmitWithResponse(ctx context.Context, params *GetSubmitParams, reqEditors ...RequestEditorFn) (*GetSubmitResponse, error)

	// GetTasks request
	GetTasksWithResponse(ctx context.Context, params *GetTasksParams, reqEditors ...RequestEditorFn) (*GetTasksResponse, error)

	// PostTasksCancelId request
	PostTasksCancelIdWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*PostTasksCancelIdResponse, error)

	// GetTasksCount request
	GetTasksCountWithResponse(ctx context.Context, params *GetTasksCountParams, reqEditors ...RequestEditorFn) (*GetTasksCountResponse, error)

	// GetTasksRunsId request
	GetTasksRunsIdWithResponse(ctx context.Context, id int64, params *GetTasksRunsIdParams, reqEditors ...RequestEditorFn) (*GetTasksRunsIdResponse, error)

	// GetTasksRunsIdCount request
	GetTasksRunsIdCountWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetTasksRunsIdCountResponse, error)

	// GetTasksSubscribed request
	GetTasksSubscribedWithResponse(ctx context.Context, params *GetTasksSubscribedParams, reqEditors ...RequestEditorFn) (*GetTasksSubscribedResponse, error)

	// DeleteToken request
	DeleteTokenWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteTokenResponse, error)

	// GetToken request
	GetTokenWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTokenResponse, error)

	// GetUserProperties request
	GetUserPropertiesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserPropertiesResponse, error)
}

type PostCancelRunIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PostCancelRunIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCancelRunIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCapabilitiesUsernameCapabilityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteCapabilitiesUsernameCapabilityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCapabilitiesUsernameCapabilityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCapabilitiesUsernameCapabilityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PostCapabilitiesUsernameCapabilityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCapabilitiesUsernameCapabilityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetErrorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]UserError
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetErrorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetErrorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogAttachIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetLogAttachIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogAttachIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLoggedinResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetLoggedinResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLoggedinResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetLoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLoginUpgradeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetLoginUpgradeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLoginUpgradeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogoutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetLogoutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogoutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRepositoriesCiAddOwnerRepoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetRepositoriesCiAddOwnerRepoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRepositoriesCiAddOwnerRepoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRepositoriesCiDelOwnerRepoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetRepositoriesCiDelOwnerRepoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRepositoriesCiDelOwnerRepoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRepositoriesMyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RepositoryList
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetRepositoriesMyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRepositoriesMyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRepositoriesScanResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetRepositoriesScanResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRepositoriesScanResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRepositoriesSubAddOwnerRepoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetRepositoriesSubAddOwnerRepoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRepositoriesSubAddOwnerRepoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRepositoriesSubDelOwnerRepoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetRepositoriesSubDelOwnerRepoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRepositoriesSubDelOwnerRepoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRepositoriesSubscribedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RepositoryList
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetRepositoriesSubscribedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRepositoriesSubscribedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRepositoriesVisibleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RepositoryList
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetRepositoriesVisibleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRepositoriesVisibleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRunRunIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Run
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetRunRunIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRunRunIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRunsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RunList
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetRunsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRunsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRunsCountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int64
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetRunsCountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRunsCountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubmissionIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ModelSubmission
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSubmissionIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubmissionIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSubmissionIdCancelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PostSubmissionIdCancelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSubmissionIdCancelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubmissionIdRunsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RunList
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSubmissionIdRunsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubmissionIdRunsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubmissionIdTasksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TaskList
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSubmissionIdTasksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubmissionIdTasksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubmissionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ModelSubmissionList
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSubmissionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubmissionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubmissionsCountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int64
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSubmissionsCountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubmissionsCountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubmitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSubmitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubmitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTasksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TaskList
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetTasksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTasksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostTasksCancelIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PostTasksCancelIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostTasksCancelIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTasksCountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int64
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetTasksCountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTasksCountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTasksRunsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RunList
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetTasksRunsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTasksRunsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTasksRunsIdCountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int64
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetTasksRunsIdCountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTasksRunsIdCountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTasksSubscribedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TaskList
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetTasksSubscribedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTasksSubscribedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalProperties map[string]interface{} `json:"-"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetUserPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// PostCancelRunIdWithResponse request returning *PostCancelRunIdResponse
func (c *ClientWithResponses) PostCancelRunIdWithResponse(ctx context.Context, runId int64, reqEditors ...RequestEditorFn) (*PostCancelRunIdResponse, error) {
	rsp, err := c.PostCancelRunId(ctx, runId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCancelRunIdResponse(rsp)
}

// DeleteCapabilitiesUsernameCapabilityWithResponse request returning *DeleteCapabilitiesUsernameCapabilityResponse
func (c *ClientWithResponses) DeleteCapabilitiesUsernameCapabilityWithResponse(ctx context.Context, username string, capability string, reqEditors ...RequestEditorFn) (*DeleteCapabilitiesUsernameCapabilityResponse, error) {
	rsp, err := c.DeleteCapabilitiesUsernameCapability(ctx, username, capability, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCapabilitiesUsernameCapabilityResponse(rsp)
}

// PostCapabilitiesUsernameCapabilityWithResponse request returning *PostCapabilitiesUsernameCapabilityResponse
func (c *ClientWithResponses) PostCapabilitiesUsernameCapabilityWithResponse(ctx context.Context, username string, capability string, reqEditors ...RequestEditorFn) (*PostCapabilitiesUsernameCapabilityResponse, error) {
	rsp, err := c.PostCapabilitiesUsernameCapability(ctx, username, capability, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCapabilitiesUsernameCapabilityResponse(rsp)
}

// GetErrorsWithResponse request returning *GetErrorsResponse
func (c *ClientWithResponses) GetErrorsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetErrorsResponse, error) {
	rsp, err := c.GetErrors(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetErrorsResponse(rsp)
}

// GetLogAttachIdWithResponse request returning *GetLogAttachIdResponse
func (c *ClientWithResponses) GetLogAttachIdWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetLogAttachIdResponse, error) {
	rsp, err := c.GetLogAttachId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogAttachIdResponse(rsp)
}

// GetLoggedinWithResponse request returning *GetLoggedinResponse
func (c *ClientWithResponses) GetLoggedinWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLoggedinResponse, error) {
	rsp, err := c.GetLoggedin(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLoggedinResponse(rsp)
}

// GetLoginWithResponse request returning *GetLoginResponse
func (c *ClientWithResponses) GetLoginWithResponse(ctx context.Context, params *GetLoginParams, reqEditors ...RequestEditorFn) (*GetLoginResponse, error) {
	rsp, err := c.GetLogin(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLoginResponse(rsp)
}

// GetLoginUpgradeWithResponse request returning *GetLoginUpgradeResponse
func (c *ClientWithResponses) GetLoginUpgradeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLoginUpgradeResponse, error) {
	rsp, err := c.GetLoginUpgrade(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLoginUpgradeResponse(rsp)
}

// GetLogoutWithResponse request returning *GetLogoutResponse
func (c *ClientWithResponses) GetLogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLogoutResponse, error) {
	rsp, err := c.GetLogout(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogoutResponse(rsp)
}

// GetRepositoriesCiAddOwnerRepoWithResponse request returning *GetRepositoriesCiAddOwnerRepoResponse
func (c *ClientWithResponses) GetRepositoriesCiAddOwnerRepoWithResponse(ctx context.Context, owner string, repo string, reqEditors ...RequestEditorFn) (*GetRepositoriesCiAddOwnerRepoResponse, error) {
	rsp, err := c.GetRepositoriesCiAddOwnerRepo(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRepositoriesCiAddOwnerRepoResponse(rsp)
}

// GetRepositoriesCiDelOwnerRepoWithResponse request returning *GetRepositoriesCiDelOwnerRepoResponse
func (c *ClientWithResponses) GetRepositoriesCiDelOwnerRepoWithResponse(ctx context.Context, owner string, repo string, reqEditors ...RequestEditorFn) (*GetRepositoriesCiDelOwnerRepoResponse, error) {
	rsp, err := c.GetRepositoriesCiDelOwnerRepo(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRepositoriesCiDelOwnerRepoResponse(rsp)
}

// GetRepositoriesMyWithResponse request returning *GetRepositoriesMyResponse
func (c *ClientWithResponses) GetRepositoriesMyWithResponse(ctx context.Context, params *GetRepositoriesMyParams, reqEditors ...RequestEditorFn) (*GetRepositoriesMyResponse, error) {
	rsp, err := c.GetRepositoriesMy(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRepositoriesMyResponse(rsp)
}

// GetRepositoriesScanWithResponse request returning *GetRepositoriesScanResponse
func (c *ClientWithResponses) GetRepositoriesScanWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRepositoriesScanResponse, error) {
	rsp, err := c.GetRepositoriesScan(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRepositoriesScanResponse(rsp)
}

// GetRepositoriesSubAddOwnerRepoWithResponse request returning *GetRepositoriesSubAddOwnerRepoResponse
func (c *ClientWithResponses) GetRepositoriesSubAddOwnerRepoWithResponse(ctx context.Context, owner string, repo string, reqEditors ...RequestEditorFn) (*GetRepositoriesSubAddOwnerRepoResponse, error) {
	rsp, err := c.GetRepositoriesSubAddOwnerRepo(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRepositoriesSubAddOwnerRepoResponse(rsp)
}

// GetRepositoriesSubDelOwnerRepoWithResponse request returning *GetRepositoriesSubDelOwnerRepoResponse
func (c *ClientWithResponses) GetRepositoriesSubDelOwnerRepoWithResponse(ctx context.Context, owner string, repo string, reqEditors ...RequestEditorFn) (*GetRepositoriesSubDelOwnerRepoResponse, error) {
	rsp, err := c.GetRepositoriesSubDelOwnerRepo(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRepositoriesSubDelOwnerRepoResponse(rsp)
}

// GetRepositoriesSubscribedWithResponse request returning *GetRepositoriesSubscribedResponse
func (c *ClientWithResponses) GetRepositoriesSubscribedWithResponse(ctx context.Context, params *GetRepositoriesSubscribedParams, reqEditors ...RequestEditorFn) (*GetRepositoriesSubscribedResponse, error) {
	rsp, err := c.GetRepositoriesSubscribed(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRepositoriesSubscribedResponse(rsp)
}

// GetRepositoriesVisibleWithResponse request returning *GetRepositoriesVisibleResponse
func (c *ClientWithResponses) GetRepositoriesVisibleWithResponse(ctx context.Context, params *GetRepositoriesVisibleParams, reqEditors ...RequestEditorFn) (*GetRepositoriesVisibleResponse, error) {
	rsp, err := c.GetRepositoriesVisible(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRepositoriesVisibleResponse(rsp)
}

// GetRunRunIdWithResponse request returning *GetRunRunIdResponse
func (c *ClientWithResponses) GetRunRunIdWithResponse(ctx context.Context, runId int64, reqEditors ...RequestEditorFn) (*GetRunRunIdResponse, error) {
	rsp, err := c.GetRunRunId(ctx, runId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRunRunIdResponse(rsp)
}

// GetRunsWithResponse request returning *GetRunsResponse
func (c *ClientWithResponses) GetRunsWithResponse(ctx context.Context, params *GetRunsParams, reqEditors ...RequestEditorFn) (*GetRunsResponse, error) {
	rsp, err := c.GetRuns(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRunsResponse(rsp)
}

// GetRunsCountWithResponse request returning *GetRunsCountResponse
func (c *ClientWithResponses) GetRunsCountWithResponse(ctx context.Context, params *GetRunsCountParams, reqEditors ...RequestEditorFn) (*GetRunsCountResponse, error) {
	rsp, err := c.GetRunsCount(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRunsCountResponse(rsp)
}

// GetSubmissionIdWithResponse request returning *GetSubmissionIdResponse
func (c *ClientWithResponses) GetSubmissionIdWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetSubmissionIdResponse, error) {
	rsp, err := c.GetSubmissionId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubmissionIdResponse(rsp)
}

// PostSubmissionIdCancelWithResponse request returning *PostSubmissionIdCancelResponse
func (c *ClientWithResponses) PostSubmissionIdCancelWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*PostSubmissionIdCancelResponse, error) {
	rsp, err := c.PostSubmissionIdCancel(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSubmissionIdCancelResponse(rsp)
}

// GetSubmissionIdRunsWithResponse request returning *GetSubmissionIdRunsResponse
func (c *ClientWithResponses) GetSubmissionIdRunsWithResponse(ctx context.Context, id int64, params *GetSubmissionIdRunsParams, reqEditors ...RequestEditorFn) (*GetSubmissionIdRunsResponse, error) {
	rsp, err := c.GetSubmissionIdRuns(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubmissionIdRunsResponse(rsp)
}

// GetSubmissionIdTasksWithResponse request returning *GetSubmissionIdTasksResponse
func (c *ClientWithResponses) GetSubmissionIdTasksWithResponse(ctx context.Context, id int64, params *GetSubmissionIdTasksParams, reqEditors ...RequestEditorFn) (*GetSubmissionIdTasksResponse, error) {
	rsp, err := c.GetSubmissionIdTasks(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubmissionIdTasksResponse(rsp)
}

// GetSubmissionsWithResponse request returning *GetSubmissionsResponse
func (c *ClientWithResponses) GetSubmissionsWithResponse(ctx context.Context, params *GetSubmissionsParams, reqEditors ...RequestEditorFn) (*GetSubmissionsResponse, error) {
	rsp, err := c.GetSubmissions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubmissionsResponse(rsp)
}

// GetSubmissionsCountWithResponse request returning *GetSubmissionsCountResponse
func (c *ClientWithResponses) GetSubmissionsCountWithResponse(ctx context.Context, params *GetSubmissionsCountParams, reqEditors ...RequestEditorFn) (*GetSubmissionsCountResponse, error) {
	rsp, err := c.GetSubmissionsCount(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubmissionsCountResponse(rsp)
}

// GetSubmitWithResponse request returning *GetSubmitResponse
func (c *ClientWithResponses) GetSubmitWithResponse(ctx context.Context, params *GetSubmitParams, reqEditors ...RequestEditorFn) (*GetSubmitResponse, error) {
	rsp, err := c.GetSubmit(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubmitResponse(rsp)
}

// GetTasksWithResponse request returning *GetTasksResponse
func (c *ClientWithResponses) GetTasksWithResponse(ctx context.Context, params *GetTasksParams, reqEditors ...RequestEditorFn) (*GetTasksResponse, error) {
	rsp, err := c.GetTasks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTasksResponse(rsp)
}

// PostTasksCancelIdWithResponse request returning *PostTasksCancelIdResponse
func (c *ClientWithResponses) PostTasksCancelIdWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*PostTasksCancelIdResponse, error) {
	rsp, err := c.PostTasksCancelId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTasksCancelIdResponse(rsp)
}

// GetTasksCountWithResponse request returning *GetTasksCountResponse
func (c *ClientWithResponses) GetTasksCountWithResponse(ctx context.Context, params *GetTasksCountParams, reqEditors ...RequestEditorFn) (*GetTasksCountResponse, error) {
	rsp, err := c.GetTasksCount(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTasksCountResponse(rsp)
}

// GetTasksRunsIdWithResponse request returning *GetTasksRunsIdResponse
func (c *ClientWithResponses) GetTasksRunsIdWithResponse(ctx context.Context, id int64, params *GetTasksRunsIdParams, reqEditors ...RequestEditorFn) (*GetTasksRunsIdResponse, error) {
	rsp, err := c.GetTasksRunsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTasksRunsIdResponse(rsp)
}

// GetTasksRunsIdCountWithResponse request returning *GetTasksRunsIdCountResponse
func (c *ClientWithResponses) GetTasksRunsIdCountWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetTasksRunsIdCountResponse, error) {
	rsp, err := c.GetTasksRunsIdCount(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTasksRunsIdCountResponse(rsp)
}

// GetTasksSubscribedWithResponse request returning *GetTasksSubscribedResponse
func (c *ClientWithResponses) GetTasksSubscribedWithResponse(ctx context.Context, params *GetTasksSubscribedParams, reqEditors ...RequestEditorFn) (*GetTasksSubscribedResponse, error) {
	rsp, err := c.GetTasksSubscribed(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTasksSubscribedResponse(rsp)
}

// DeleteTokenWithResponse request returning *DeleteTokenResponse
func (c *ClientWithResponses) DeleteTokenWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteTokenResponse, error) {
	rsp, err := c.DeleteToken(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTokenResponse(rsp)
}

// GetTokenWithResponse request returning *GetTokenResponse
func (c *ClientWithResponses) GetTokenWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTokenResponse, error) {
	rsp, err := c.GetToken(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTokenResponse(rsp)
}

// GetUserPropertiesWithResponse request returning *GetUserPropertiesResponse
func (c *ClientWithResponses) GetUserPropertiesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserPropertiesResponse, error) {
	rsp, err := c.GetUserProperties(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserPropertiesResponse(rsp)
}

// ParsePostCancelRunIdResponse parses an HTTP response from a PostCancelRunIdWithResponse call
func ParsePostCancelRunIdResponse(rsp *http.Response) (*PostCancelRunIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PostCancelRunIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteCapabilitiesUsernameCapabilityResponse parses an HTTP response from a DeleteCapabilitiesUsernameCapabilityWithResponse call
func ParseDeleteCapabilitiesUsernameCapabilityResponse(rsp *http.Response) (*DeleteCapabilitiesUsernameCapabilityResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteCapabilitiesUsernameCapabilityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostCapabilitiesUsernameCapabilityResponse parses an HTTP response from a PostCapabilitiesUsernameCapabilityWithResponse call
func ParsePostCapabilitiesUsernameCapabilityResponse(rsp *http.Response) (*PostCapabilitiesUsernameCapabilityResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PostCapabilitiesUsernameCapabilityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetErrorsResponse parses an HTTP response from a GetErrorsWithResponse call
func ParseGetErrorsResponse(rsp *http.Response) (*GetErrorsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetErrorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []UserError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLogAttachIdResponse parses an HTTP response from a GetLogAttachIdWithResponse call
func ParseGetLogAttachIdResponse(rsp *http.Response) (*GetLogAttachIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetLogAttachIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLoggedinResponse parses an HTTP response from a GetLoggedinWithResponse call
func ParseGetLoggedinResponse(rsp *http.Response) (*GetLoggedinResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetLoggedinResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLoginResponse parses an HTTP response from a GetLoginWithResponse call
func ParseGetLoginResponse(rsp *http.Response) (*GetLoginResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetLoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLoginUpgradeResponse parses an HTTP response from a GetLoginUpgradeWithResponse call
func ParseGetLoginUpgradeResponse(rsp *http.Response) (*GetLoginUpgradeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetLoginUpgradeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLogoutResponse parses an HTTP response from a GetLogoutWithResponse call
func ParseGetLogoutResponse(rsp *http.Response) (*GetLogoutResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetLogoutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRepositoriesCiAddOwnerRepoResponse parses an HTTP response from a GetRepositoriesCiAddOwnerRepoWithResponse call
func ParseGetRepositoriesCiAddOwnerRepoResponse(rsp *http.Response) (*GetRepositoriesCiAddOwnerRepoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetRepositoriesCiAddOwnerRepoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRepositoriesCiDelOwnerRepoResponse parses an HTTP response from a GetRepositoriesCiDelOwnerRepoWithResponse call
func ParseGetRepositoriesCiDelOwnerRepoResponse(rsp *http.Response) (*GetRepositoriesCiDelOwnerRepoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetRepositoriesCiDelOwnerRepoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRepositoriesMyResponse parses an HTTP response from a GetRepositoriesMyWithResponse call
func ParseGetRepositoriesMyResponse(rsp *http.Response) (*GetRepositoriesMyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetRepositoriesMyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RepositoryList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRepositoriesScanResponse parses an HTTP response from a GetRepositoriesScanWithResponse call
func ParseGetRepositoriesScanResponse(rsp *http.Response) (*GetRepositoriesScanResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetRepositoriesScanResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRepositoriesSubAddOwnerRepoResponse parses an HTTP response from a GetRepositoriesSubAddOwnerRepoWithResponse call
func ParseGetRepositoriesSubAddOwnerRepoResponse(rsp *http.Response) (*GetRepositoriesSubAddOwnerRepoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetRepositoriesSubAddOwnerRepoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRepositoriesSubDelOwnerRepoResponse parses an HTTP response from a GetRepositoriesSubDelOwnerRepoWithResponse call
func ParseGetRepositoriesSubDelOwnerRepoResponse(rsp *http.Response) (*GetRepositoriesSubDelOwnerRepoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetRepositoriesSubDelOwnerRepoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRepositoriesSubscribedResponse parses an HTTP response from a GetRepositoriesSubscribedWithResponse call
func ParseGetRepositoriesSubscribedResponse(rsp *http.Response) (*GetRepositoriesSubscribedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetRepositoriesSubscribedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RepositoryList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRepositoriesVisibleResponse parses an HTTP response from a GetRepositoriesVisibleWithResponse call
func ParseGetRepositoriesVisibleResponse(rsp *http.Response) (*GetRepositoriesVisibleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetRepositoriesVisibleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RepositoryList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRunRunIdResponse parses an HTTP response from a GetRunRunIdWithResponse call
func ParseGetRunRunIdResponse(rsp *http.Response) (*GetRunRunIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetRunRunIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Run
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRunsResponse parses an HTTP response from a GetRunsWithResponse call
func ParseGetRunsResponse(rsp *http.Response) (*GetRunsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetRunsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RunList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRunsCountResponse parses an HTTP response from a GetRunsCountWithResponse call
func ParseGetRunsCountResponse(rsp *http.Response) (*GetRunsCountResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetRunsCountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int64
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSubmissionIdResponse parses an HTTP response from a GetSubmissionIdWithResponse call
func ParseGetSubmissionIdResponse(rsp *http.Response) (*GetSubmissionIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetSubmissionIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ModelSubmission
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSubmissionIdCancelResponse parses an HTTP response from a PostSubmissionIdCancelWithResponse call
func ParsePostSubmissionIdCancelResponse(rsp *http.Response) (*PostSubmissionIdCancelResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PostSubmissionIdCancelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSubmissionIdRunsResponse parses an HTTP response from a GetSubmissionIdRunsWithResponse call
func ParseGetSubmissionIdRunsResponse(rsp *http.Response) (*GetSubmissionIdRunsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetSubmissionIdRunsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RunList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSubmissionIdTasksResponse parses an HTTP response from a GetSubmissionIdTasksWithResponse call
func ParseGetSubmissionIdTasksResponse(rsp *http.Response) (*GetSubmissionIdTasksResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetSubmissionIdTasksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaskList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSubmissionsResponse parses an HTTP response from a GetSubmissionsWithResponse call
func ParseGetSubmissionsResponse(rsp *http.Response) (*GetSubmissionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetSubmissionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ModelSubmissionList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSubmissionsCountResponse parses an HTTP response from a GetSubmissionsCountWithResponse call
func ParseGetSubmissionsCountResponse(rsp *http.Response) (*GetSubmissionsCountResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetSubmissionsCountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int64
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSubmitResponse parses an HTTP response from a GetSubmitWithResponse call
func ParseGetSubmitResponse(rsp *http.Response) (*GetSubmitResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetSubmitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTasksResponse parses an HTTP response from a GetTasksWithResponse call
func ParseGetTasksResponse(rsp *http.Response) (*GetTasksResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetTasksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaskList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostTasksCancelIdResponse parses an HTTP response from a PostTasksCancelIdWithResponse call
func ParsePostTasksCancelIdResponse(rsp *http.Response) (*PostTasksCancelIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PostTasksCancelIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTasksCountResponse parses an HTTP response from a GetTasksCountWithResponse call
func ParseGetTasksCountResponse(rsp *http.Response) (*GetTasksCountResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetTasksCountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int64
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTasksRunsIdResponse parses an HTTP response from a GetTasksRunsIdWithResponse call
func ParseGetTasksRunsIdResponse(rsp *http.Response) (*GetTasksRunsIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetTasksRunsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RunList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTasksRunsIdCountResponse parses an HTTP response from a GetTasksRunsIdCountWithResponse call
func ParseGetTasksRunsIdCountResponse(rsp *http.Response) (*GetTasksRunsIdCountResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetTasksRunsIdCountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int64
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTasksSubscribedResponse parses an HTTP response from a GetTasksSubscribedWithResponse call
func ParseGetTasksSubscribedResponse(rsp *http.Response) (*GetTasksSubscribedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetTasksSubscribedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaskList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteTokenResponse parses an HTTP response from a DeleteTokenWithResponse call
func ParseDeleteTokenResponse(rsp *http.Response) (*DeleteTokenResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTokenResponse parses an HTTP response from a GetTokenWithResponse call
func ParseGetTokenResponse(rsp *http.Response) (*GetTokenResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserPropertiesResponse parses an HTTP response from a GetUserPropertiesWithResponse call
func ParseGetUserPropertiesResponse(rsp *http.Response) (*GetUserPropertiesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetUserPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalProperties map[string]interface{} `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Cancel by Run ID
	// (POST /cancel/{run_id})
	PostCancelRunId(ctx echo.Context, runId int64) error
	// Remove a named capability
	// (DELETE /capabilities/{username}/{capability})
	DeleteCapabilitiesUsernameCapability(ctx echo.Context, username string, capability string) error
	// Add a named capability
	// (POST /capabilities/{username}/{capability})
	PostCapabilitiesUsernameCapability(ctx echo.Context, username string, capability string) error
	// Retrieve errors
	// (GET /errors)
	GetErrors(ctx echo.Context) error
	// Attach to a running log
	// (GET /log/attach/{id})
	GetLogAttachId(ctx echo.Context, id int64) error
	// Check logged in state
	// (GET /loggedin)
	GetLoggedin(ctx echo.Context) error
	// Log into the system
	// (GET /login)
	GetLogin(ctx echo.Context, params GetLoginParams) error
	// Log into the system with upgraded permissions
	// (GET /login/upgrade)
	GetLoginUpgrade(ctx echo.Context) error
	// Log out of the system
	// (GET /logout)
	GetLogout(ctx echo.Context) error
	// Add a specific repository to CI.
	// (GET /repositories/ci/add/{owner}/{repo})
	GetRepositoriesCiAddOwnerRepo(ctx echo.Context, owner string, repo string) error
	// Removes a specific repository from CI.
	// (GET /repositories/ci/del/{owner}/{repo})
	GetRepositoriesCiDelOwnerRepo(ctx echo.Context, owner string, repo string) error
	// Fetch all the writable repositories for the user.
	// (GET /repositories/my)
	GetRepositoriesMy(ctx echo.Context, params GetRepositoriesMyParams) error
	// Scan repositories from the remote resource
	// (GET /repositories/scan)
	GetRepositoriesScan(ctx echo.Context) error
	// Subscribe to a repository running CI
	// (GET /repositories/sub/add/{owner}/{repo})
	GetRepositoriesSubAddOwnerRepo(ctx echo.Context, owner string, repo string) error
	// Unsubscribe from a repository
	// (GET /repositories/sub/del/{owner}/{repo})
	GetRepositoriesSubDelOwnerRepo(ctx echo.Context, owner string, repo string) error
	// List all subscribed repositories
	// (GET /repositories/subscribed)
	GetRepositoriesSubscribed(ctx echo.Context, params GetRepositoriesSubscribedParams) error
	// Fetch all the repositories the user can view.
	// (GET /repositories/visible)
	GetRepositoriesVisible(ctx echo.Context, params GetRepositoriesVisibleParams) error
	// Get a run by ID
	// (GET /run/{run_id})
	GetRunRunId(ctx echo.Context, runId int64) error
	// Obtain the run list for the user
	// (GET /runs)
	GetRuns(ctx echo.Context, params GetRunsParams) error
	// Count the runs
	// (GET /runs/count)
	GetRunsCount(ctx echo.Context, params GetRunsCountParams) error
	// Get a submission by ID
	// (GET /submission/{id})
	GetSubmissionId(ctx echo.Context, id int64) error
	// Cancel a submission by ID
	// (POST /submission/{id}/cancel)
	PostSubmissionIdCancel(ctx echo.Context, id int64) error
	// Get submission runs by ID
	// (GET /submission/{id}/runs)
	GetSubmissionIdRuns(ctx echo.Context, id int64, params GetSubmissionIdRunsParams) error
	// Get submission tasks by ID
	// (GET /submission/{id}/tasks)
	GetSubmissionIdTasks(ctx echo.Context, id int64, params GetSubmissionIdTasksParams) error
	// List submisssions
	// (GET /submissions)
	GetSubmissions(ctx echo.Context, params GetSubmissionsParams) error
	// Count submisssions
	// (GET /submissions/count)
	GetSubmissionsCount(ctx echo.Context, params GetSubmissionsCountParams) error
	// Perform a manual submission to tinyCI
	// (GET /submit)
	GetSubmit(ctx echo.Context, params GetSubmitParams) error
	// Obtain the task list optionally filtering by repository and sha.
	// (GET /tasks)
	GetTasks(ctx echo.Context, params GetTasksParams) error
	// Cancel by Task ID
	// (POST /tasks/cancel/{id})
	PostTasksCancelId(ctx echo.Context, id int64) error
	// Count the Tasks
	// (GET /tasks/count)
	GetTasksCount(ctx echo.Context, params GetTasksCountParams) error
	// Obtain the run list based on the task ID.
	// (GET /tasks/runs/{id})
	GetTasksRunsId(ctx echo.Context, id int64, params GetTasksRunsIdParams) error
	// Count the runs corresponding to the task ID.
	// (GET /tasks/runs/{id}/count)
	GetTasksRunsIdCount(ctx echo.Context, id int64) error
	// Obtain the list of tasks that belong to repositories you are subscribed to.
	// (GET /tasks/subscribed)
	GetTasksSubscribed(ctx echo.Context, params GetTasksSubscribedParams) error
	// Remove and reset your tinyCI access token
	// (DELETE /token)
	DeleteToken(ctx echo.Context) error
	// Get a tinyCI access token
	// (GET /token)
	GetToken(ctx echo.Context) error
	// Get information about the current user
	// (GET /user/properties)
	GetUserProperties(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// PostCancelRunId converts echo context to params.
func (w *ServerInterfaceWrapper) PostCancelRunId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "run_id" -------------
	var runId int64

	err = runtime.BindStyledParameterWithLocation("simple", false, "run_id", runtime.ParamLocationPath, ctx.Param("run_id"), &runId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter run_id: %s", err))
	}

	ctx.Set(TokenScopes, []string{""})

	ctx.Set(SessionScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostCancelRunId(ctx, runId)
	return err
}

// DeleteCapabilitiesUsernameCapability converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteCapabilitiesUsernameCapability(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "username" -------------
	var username string

	err = runtime.BindStyledParameterWithLocation("simple", false, "username", runtime.ParamLocationPath, ctx.Param("username"), &username)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter username: %s", err))
	}

	// ------------- Path parameter "capability" -------------
	var capability string

	err = runtime.BindStyledParameterWithLocation("simple", false, "capability", runtime.ParamLocationPath, ctx.Param("capability"), &capability)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter capability: %s", err))
	}

	ctx.Set(SessionScopes, []string{""})

	ctx.Set(TokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteCapabilitiesUsernameCapability(ctx, username, capability)
	return err
}

// PostCapabilitiesUsernameCapability converts echo context to params.
func (w *ServerInterfaceWrapper) PostCapabilitiesUsernameCapability(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "username" -------------
	var username string

	err = runtime.BindStyledParameterWithLocation("simple", false, "username", runtime.ParamLocationPath, ctx.Param("username"), &username)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter username: %s", err))
	}

	// ------------- Path parameter "capability" -------------
	var capability string

	err = runtime.BindStyledParameterWithLocation("simple", false, "capability", runtime.ParamLocationPath, ctx.Param("capability"), &capability)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter capability: %s", err))
	}

	ctx.Set(SessionScopes, []string{""})

	ctx.Set(TokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostCapabilitiesUsernameCapability(ctx, username, capability)
	return err
}

// GetErrors converts echo context to params.
func (w *ServerInterfaceWrapper) GetErrors(ctx echo.Context) error {
	var err error

	ctx.Set(SessionScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetErrors(ctx)
	return err
}

// GetLogAttachId converts echo context to params.
func (w *ServerInterfaceWrapper) GetLogAttachId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int64

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(TokenScopes, []string{""})

	ctx.Set(SessionScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLogAttachId(ctx, id)
	return err
}

// GetLoggedin converts echo context to params.
func (w *ServerInterfaceWrapper) GetLoggedin(ctx echo.Context) error {
	var err error

	ctx.Set(TokenScopes, []string{""})

	ctx.Set(SessionScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLoggedin(ctx)
	return err
}

// GetLogin converts echo context to params.
func (w *ServerInterfaceWrapper) GetLogin(ctx echo.Context) error {
	var err error

	ctx.Set(TokenScopes, []string{""})

	ctx.Set(SessionScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLoginParams
	// ------------- Required query parameter "code" -------------

	err = runtime.BindQueryParameter("form", true, true, "code", ctx.QueryParams(), &params.Code)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
	}

	// ------------- Required query parameter "state" -------------

	err = runtime.BindQueryParameter("form", true, true, "state", ctx.QueryParams(), &params.State)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter state: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLogin(ctx, params)
	return err
}

// GetLoginUpgrade converts echo context to params.
func (w *ServerInterfaceWrapper) GetLoginUpgrade(ctx echo.Context) error {
	var err error

	ctx.Set(TokenScopes, []string{""})

	ctx.Set(SessionScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLoginUpgrade(ctx)
	return err
}

// GetLogout converts echo context to params.
func (w *ServerInterfaceWrapper) GetLogout(ctx echo.Context) error {
	var err error

	ctx.Set(SessionScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLogout(ctx)
	return err
}

// GetRepositoriesCiAddOwnerRepo converts echo context to params.
func (w *ServerInterfaceWrapper) GetRepositoriesCiAddOwnerRepo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "owner" -------------
	var owner string

	err = runtime.BindStyledParameterWithLocation("simple", false, "owner", runtime.ParamLocationPath, ctx.Param("owner"), &owner)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter owner: %s", err))
	}

	// ------------- Path parameter "repo" -------------
	var repo string

	err = runtime.BindStyledParameterWithLocation("simple", false, "repo", runtime.ParamLocationPath, ctx.Param("repo"), &repo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter repo: %s", err))
	}

	ctx.Set(TokenScopes, []string{""})

	ctx.Set(SessionScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRepositoriesCiAddOwnerRepo(ctx, owner, repo)
	return err
}

// GetRepositoriesCiDelOwnerRepo converts echo context to params.
func (w *ServerInterfaceWrapper) GetRepositoriesCiDelOwnerRepo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "owner" -------------
	var owner string

	err = runtime.BindStyledParameterWithLocation("simple", false, "owner", runtime.ParamLocationPath, ctx.Param("owner"), &owner)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter owner: %s", err))
	}

	// ------------- Path parameter "repo" -------------
	var repo string

	err = runtime.BindStyledParameterWithLocation("simple", false, "repo", runtime.ParamLocationPath, ctx.Param("repo"), &repo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter repo: %s", err))
	}

	ctx.Set(TokenScopes, []string{""})

	ctx.Set(SessionScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRepositoriesCiDelOwnerRepo(ctx, owner, repo)
	return err
}

// GetRepositoriesMy converts echo context to params.
func (w *ServerInterfaceWrapper) GetRepositoriesMy(ctx echo.Context) error {
	var err error

	ctx.Set(TokenScopes, []string{""})

	ctx.Set(SessionScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRepositoriesMyParams
	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", ctx.QueryParams(), &params.Search)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter search: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRepositoriesMy(ctx, params)
	return err
}

// GetRepositoriesScan converts echo context to params.
func (w *ServerInterfaceWrapper) GetRepositoriesScan(ctx echo.Context) error {
	var err error

	ctx.Set(TokenScopes, []string{""})

	ctx.Set(SessionScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRepositoriesScan(ctx)
	return err
}

// GetRepositoriesSubAddOwnerRepo converts echo context to params.
func (w *ServerInterfaceWrapper) GetRepositoriesSubAddOwnerRepo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "owner" -------------
	var owner string

	err = runtime.BindStyledParameterWithLocation("simple", false, "owner", runtime.ParamLocationPath, ctx.Param("owner"), &owner)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter owner: %s", err))
	}

	// ------------- Path parameter "repo" -------------
	var repo string

	err = runtime.BindStyledParameterWithLocation("simple", false, "repo", runtime.ParamLocationPath, ctx.Param("repo"), &repo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter repo: %s", err))
	}

	ctx.Set(TokenScopes, []string{""})

	ctx.Set(SessionScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRepositoriesSubAddOwnerRepo(ctx, owner, repo)
	return err
}

// GetRepositoriesSubDelOwnerRepo converts echo context to params.
func (w *ServerInterfaceWrapper) GetRepositoriesSubDelOwnerRepo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "owner" -------------
	var owner string

	err = runtime.BindStyledParameterWithLocation("simple", false, "owner", runtime.ParamLocationPath, ctx.Param("owner"), &owner)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter owner: %s", err))
	}

	// ------------- Path parameter "repo" -------------
	var repo string

	err = runtime.BindStyledParameterWithLocation("simple", false, "repo", runtime.ParamLocationPath, ctx.Param("repo"), &repo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter repo: %s", err))
	}

	ctx.Set(TokenScopes, []string{""})

	ctx.Set(SessionScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRepositoriesSubDelOwnerRepo(ctx, owner, repo)
	return err
}

// GetRepositoriesSubscribed converts echo context to params.
func (w *ServerInterfaceWrapper) GetRepositoriesSubscribed(ctx echo.Context) error {
	var err error

	ctx.Set(TokenScopes, []string{""})

	ctx.Set(SessionScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRepositoriesSubscribedParams
	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", ctx.QueryParams(), &params.Search)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter search: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRepositoriesSubscribed(ctx, params)
	return err
}

// GetRepositoriesVisible converts echo context to params.
func (w *ServerInterfaceWrapper) GetRepositoriesVisible(ctx echo.Context) error {
	var err error

	ctx.Set(TokenScopes, []string{""})

	ctx.Set(SessionScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRepositoriesVisibleParams
	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", ctx.QueryParams(), &params.Search)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter search: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRepositoriesVisible(ctx, params)
	return err
}

// GetRunRunId converts echo context to params.
func (w *ServerInterfaceWrapper) GetRunRunId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "run_id" -------------
	var runId int64

	err = runtime.BindStyledParameterWithLocation("simple", false, "run_id", runtime.ParamLocationPath, ctx.Param("run_id"), &runId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter run_id: %s", err))
	}

	ctx.Set(TokenScopes, []string{""})

	ctx.Set(SessionScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRunRunId(ctx, runId)
	return err
}

// GetRuns converts echo context to params.
func (w *ServerInterfaceWrapper) GetRuns(ctx echo.Context) error {
	var err error

	ctx.Set(TokenScopes, []string{""})

	ctx.Set(SessionScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRunsParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "perPage" -------------

	err = runtime.BindQueryParameter("form", true, false, "perPage", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter perPage: %s", err))
	}

	// ------------- Optional query parameter "repository" -------------

	err = runtime.BindQueryParameter("form", true, false, "repository", ctx.QueryParams(), &params.Repository)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter repository: %s", err))
	}

	// ------------- Optional query parameter "sha" -------------

	err = runtime.BindQueryParameter("form", true, false, "sha", ctx.QueryParams(), &params.Sha)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sha: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRuns(ctx, params)
	return err
}

// GetRunsCount converts echo context to params.
func (w *ServerInterfaceWrapper) GetRunsCount(ctx echo.Context) error {
	var err error

	ctx.Set(TokenScopes, []string{""})

	ctx.Set(SessionScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRunsCountParams
	// ------------- Optional query parameter "repository" -------------

	err = runtime.BindQueryParameter("form", true, false, "repository", ctx.QueryParams(), &params.Repository)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter repository: %s", err))
	}

	// ------------- Optional query parameter "sha" -------------

	err = runtime.BindQueryParameter("form", true, false, "sha", ctx.QueryParams(), &params.Sha)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sha: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRunsCount(ctx, params)
	return err
}

// GetSubmissionId converts echo context to params.
func (w *ServerInterfaceWrapper) GetSubmissionId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int64

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(TokenScopes, []string{""})

	ctx.Set(SessionScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSubmissionId(ctx, id)
	return err
}

// PostSubmissionIdCancel converts echo context to params.
func (w *ServerInterfaceWrapper) PostSubmissionIdCancel(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int64

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(TokenScopes, []string{""})

	ctx.Set(SessionScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostSubmissionIdCancel(ctx, id)
	return err
}

// GetSubmissionIdRuns converts echo context to params.
func (w *ServerInterfaceWrapper) GetSubmissionIdRuns(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int64

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(TokenScopes, []string{""})

	ctx.Set(SessionScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSubmissionIdRunsParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "perPage" -------------

	err = runtime.BindQueryParameter("form", true, false, "perPage", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter perPage: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSubmissionIdRuns(ctx, id, params)
	return err
}

// GetSubmissionIdTasks converts echo context to params.
func (w *ServerInterfaceWrapper) GetSubmissionIdTasks(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int64

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(TokenScopes, []string{""})

	ctx.Set(SessionScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSubmissionIdTasksParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "perPage" -------------

	err = runtime.BindQueryParameter("form", true, false, "perPage", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter perPage: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSubmissionIdTasks(ctx, id, params)
	return err
}

// GetSubmissions converts echo context to params.
func (w *ServerInterfaceWrapper) GetSubmissions(ctx echo.Context) error {
	var err error

	ctx.Set(TokenScopes, []string{""})

	ctx.Set(SessionScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSubmissionsParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "perPage" -------------

	err = runtime.BindQueryParameter("form", true, false, "perPage", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter perPage: %s", err))
	}

	// ------------- Optional query parameter "repository" -------------

	err = runtime.BindQueryParameter("form", true, false, "repository", ctx.QueryParams(), &params.Repository)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter repository: %s", err))
	}

	// ------------- Optional query parameter "sha" -------------

	err = runtime.BindQueryParameter("form", true, false, "sha", ctx.QueryParams(), &params.Sha)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sha: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSubmissions(ctx, params)
	return err
}

// GetSubmissionsCount converts echo context to params.
func (w *ServerInterfaceWrapper) GetSubmissionsCount(ctx echo.Context) error {
	var err error

	ctx.Set(TokenScopes, []string{""})

	ctx.Set(SessionScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSubmissionsCountParams
	// ------------- Optional query parameter "repository" -------------

	err = runtime.BindQueryParameter("form", true, false, "repository", ctx.QueryParams(), &params.Repository)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter repository: %s", err))
	}

	// ------------- Optional query parameter "sha" -------------

	err = runtime.BindQueryParameter("form", true, false, "sha", ctx.QueryParams(), &params.Sha)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sha: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSubmissionsCount(ctx, params)
	return err
}

// GetSubmit converts echo context to params.
func (w *ServerInterfaceWrapper) GetSubmit(ctx echo.Context) error {
	var err error

	ctx.Set(SessionScopes, []string{""})

	ctx.Set(TokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSubmitParams
	// ------------- Required query parameter "repository" -------------

	err = runtime.BindQueryParameter("form", true, true, "repository", ctx.QueryParams(), &params.Repository)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter repository: %s", err))
	}

	// ------------- Required query parameter "sha" -------------

	err = runtime.BindQueryParameter("form", true, true, "sha", ctx.QueryParams(), &params.Sha)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sha: %s", err))
	}

	// ------------- Optional query parameter "all" -------------

	err = runtime.BindQueryParameter("form", true, false, "all", ctx.QueryParams(), &params.All)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSubmit(ctx, params)
	return err
}

// GetTasks converts echo context to params.
func (w *ServerInterfaceWrapper) GetTasks(ctx echo.Context) error {
	var err error

	ctx.Set(TokenScopes, []string{""})

	ctx.Set(SessionScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTasksParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "perPage" -------------

	err = runtime.BindQueryParameter("form", true, false, "perPage", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter perPage: %s", err))
	}

	// ------------- Optional query parameter "repository" -------------

	err = runtime.BindQueryParameter("form", true, false, "repository", ctx.QueryParams(), &params.Repository)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter repository: %s", err))
	}

	// ------------- Optional query parameter "sha" -------------

	err = runtime.BindQueryParameter("form", true, false, "sha", ctx.QueryParams(), &params.Sha)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sha: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTasks(ctx, params)
	return err
}

// PostTasksCancelId converts echo context to params.
func (w *ServerInterfaceWrapper) PostTasksCancelId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int64

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(TokenScopes, []string{""})

	ctx.Set(SessionScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostTasksCancelId(ctx, id)
	return err
}

// GetTasksCount converts echo context to params.
func (w *ServerInterfaceWrapper) GetTasksCount(ctx echo.Context) error {
	var err error

	ctx.Set(TokenScopes, []string{""})

	ctx.Set(SessionScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTasksCountParams
	// ------------- Optional query parameter "repository" -------------

	err = runtime.BindQueryParameter("form", true, false, "repository", ctx.QueryParams(), &params.Repository)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter repository: %s", err))
	}

	// ------------- Optional query parameter "sha" -------------

	err = runtime.BindQueryParameter("form", true, false, "sha", ctx.QueryParams(), &params.Sha)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sha: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTasksCount(ctx, params)
	return err
}

// GetTasksRunsId converts echo context to params.
func (w *ServerInterfaceWrapper) GetTasksRunsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int64

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(TokenScopes, []string{""})

	ctx.Set(SessionScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTasksRunsIdParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "perPage" -------------

	err = runtime.BindQueryParameter("form", true, false, "perPage", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter perPage: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTasksRunsId(ctx, id, params)
	return err
}

// GetTasksRunsIdCount converts echo context to params.
func (w *ServerInterfaceWrapper) GetTasksRunsIdCount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int64

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(TokenScopes, []string{""})

	ctx.Set(SessionScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTasksRunsIdCount(ctx, id)
	return err
}

// GetTasksSubscribed converts echo context to params.
func (w *ServerInterfaceWrapper) GetTasksSubscribed(ctx echo.Context) error {
	var err error

	ctx.Set(TokenScopes, []string{""})

	ctx.Set(SessionScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTasksSubscribedParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "perPage" -------------

	err = runtime.BindQueryParameter("form", true, false, "perPage", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter perPage: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTasksSubscribed(ctx, params)
	return err
}

// DeleteToken converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteToken(ctx echo.Context) error {
	var err error

	ctx.Set(TokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteToken(ctx)
	return err
}

// GetToken converts echo context to params.
func (w *ServerInterfaceWrapper) GetToken(ctx echo.Context) error {
	var err error

	ctx.Set(SessionScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetToken(ctx)
	return err
}

// GetUserProperties converts echo context to params.
func (w *ServerInterfaceWrapper) GetUserProperties(ctx echo.Context) error {
	var err error

	ctx.Set(SessionScopes, []string{""})

	ctx.Set(TokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUserProperties(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/cancel/:run_id", wrapper.PostCancelRunId)
	router.DELETE(baseURL+"/capabilities/:username/:capability", wrapper.DeleteCapabilitiesUsernameCapability)
	router.POST(baseURL+"/capabilities/:username/:capability", wrapper.PostCapabilitiesUsernameCapability)
	router.GET(baseURL+"/errors", wrapper.GetErrors)
	router.GET(baseURL+"/log/attach/:id", wrapper.GetLogAttachId)
	router.GET(baseURL+"/loggedin", wrapper.GetLoggedin)
	router.GET(baseURL+"/login", wrapper.GetLogin)
	router.GET(baseURL+"/login/upgrade", wrapper.GetLoginUpgrade)
	router.GET(baseURL+"/logout", wrapper.GetLogout)
	router.GET(baseURL+"/repositories/ci/add/:owner/:repo", wrapper.GetRepositoriesCiAddOwnerRepo)
	router.GET(baseURL+"/repositories/ci/del/:owner/:repo", wrapper.GetRepositoriesCiDelOwnerRepo)
	router.GET(baseURL+"/repositories/my", wrapper.GetRepositoriesMy)
	router.GET(baseURL+"/repositories/scan", wrapper.GetRepositoriesScan)
	router.GET(baseURL+"/repositories/sub/add/:owner/:repo", wrapper.GetRepositoriesSubAddOwnerRepo)
	router.GET(baseURL+"/repositories/sub/del/:owner/:repo", wrapper.GetRepositoriesSubDelOwnerRepo)
	router.GET(baseURL+"/repositories/subscribed", wrapper.GetRepositoriesSubscribed)
	router.GET(baseURL+"/repositories/visible", wrapper.GetRepositoriesVisible)
	router.GET(baseURL+"/run/:run_id", wrapper.GetRunRunId)
	router.GET(baseURL+"/runs", wrapper.GetRuns)
	router.GET(baseURL+"/runs/count", wrapper.GetRunsCount)
	router.GET(baseURL+"/submission/:id", wrapper.GetSubmissionId)
	router.POST(baseURL+"/submission/:id/cancel", wrapper.PostSubmissionIdCancel)
	router.GET(baseURL+"/submission/:id/runs", wrapper.GetSubmissionIdRuns)
	router.GET(baseURL+"/submission/:id/tasks", wrapper.GetSubmissionIdTasks)
	router.GET(baseURL+"/submissions", wrapper.GetSubmissions)
	router.GET(baseURL+"/submissions/count", wrapper.GetSubmissionsCount)
	router.GET(baseURL+"/submit", wrapper.GetSubmit)
	router.GET(baseURL+"/tasks", wrapper.GetTasks)
	router.POST(baseURL+"/tasks/cancel/:id", wrapper.PostTasksCancelId)
	router.GET(baseURL+"/tasks/count", wrapper.GetTasksCount)
	router.GET(baseURL+"/tasks/runs/:id", wrapper.GetTasksRunsId)
	router.GET(baseURL+"/tasks/runs/:id/count", wrapper.GetTasksRunsIdCount)
	router.GET(baseURL+"/tasks/subscribed", wrapper.GetTasksSubscribed)
	router.DELETE(baseURL+"/token", wrapper.DeleteToken)
	router.GET(baseURL+"/token", wrapper.GetToken)
	router.GET(baseURL+"/user/properties", wrapper.GetUserProperties)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xdW3MbN5b+K2e5W+VkhiaVZGcfnCev7Xi061m7JHm2tsYpFdh9yIaJBjoAmgrXpf8+",
	"dQ7QF5LdZNNSIlvhi02x0bgcfN+54cJPo8TkhdGovRs9+zRySYa54I+vrDWWPhTWFGi9RP4a6Wv+JD3m",
	"/MGvCxw9GzlvpV6MbsfVF8Jasaa/lVlQuRTnolR+9MzbEutSM2MUCj26bV40s4+YeHrzbyZFdVnOcumc",
	"NHq3OzPh8NrinD7/G/8/+tdpM6ZpHND0AudUXyJ0ggrTVrfr9sejxKLwmF4LT8/nxub0aZQKj0+9zHE0",
	"3h3rXGrpsv0v6VIpMVO4NfKmkgxFesQoZLrRlNT+P/696ZvUHhdoqaAttbtOTKn9wBecF9bfcTDOC1/y",
	"5PQUbUncC7c8rodeJkv014NFUDq0h8T6nsoMwd8b6fwG9PfVuo3dDmJchCnfhPTw2cX5tRY5dnLQYmGc",
	"9MauD4OqLkmzl4mO+rpkQ++9MHouF7tjWCgzE+qaIGPKoVNrVmitTPH6lxJL7KZoXaZV9W6p7QoasdwY",
	"u0ylPWKIjRA3hyhKb66jxujuRSodob/n6UL6rJxxTWkqvTRaqHetFjYo03RpMDp6kVFYuRK+U777ZXAU",
	"+jdRtQt8Z0qbBEluyjUpys5up9ItOx9IU3SboRzzOHNDprrssC4PZhCOnmX8VeQFVTjK109tqbt6ZoW+",
	"Djb0sA5H76VeHJ7lUl9WRR/IfBzq4hWV6Zvy4yBddivxlgx2EWTyXOj0OH9J5mKBPZD2IhVeHK02erVB",
	"v6q0bY7up3pVkO3zcJXfNSlXcUq3xPhl+m2DaVoIn3ULudRuqG82kJMkwYckpdtw14/ykPoAcRRNA+F3",
	"WbUhlw6iVp7MIasWfR4ySSGgue7na1Win2VVic9jW/V2i3UpusTKwrP8Rz5DiIUgFvoRpAYttHGYGJ26",
	"0XgI+lCvjlNibVW1M6k5efyFkdrvZUW3ijvKJO00fZwH+D6GDweD4EPxRQinu5T9UB2ihPPXLhFaIwWL",
	"hXGfz2dvlqiPNiIUS/UYkj7Z7csibPotIsl8qRdjmInZ+l9Gvdq2fuO78edYGPpK6rnZpcrzd+cwNxaI",
	"MjRSoFrsXCQIDu1KJvgjP4t/gM+EB+kglRYTr9Zg0RVGOzlTyBUVFh1qQiIQEcAbrtdNPuirTLqmonUh",
	"E6GohlI7EJ6bmRmboh2D0CkoXKEVC6R3WFVCYsxSogNjQZQ+o2YSQQMBnloXeneDsECNVvjQo9A8nHsQ",
	"yhnq/HafM6FTRT2mLojEg5mDoRa4HywWtrbcUmZNuchAegfKLKSGzJglDa+UbpW0xuWFWjoaP6sj4QU9",
	"pgqNz9BWguASIiECKelCvQsj1Bikh9SgA208OLFCEHrtM+qmMqEFYyER1q6BLBVOPrADLD0ji3szGo9W",
	"aINVGn03OZuccThZoBaFHD0b/TA5m/wwCpaaIToNPsf0ky31tUxvGcTGdejYF1yQx2ZLDbM1nL8kqEgH",
	"N1IpEmMZxGBlslQIM5EsefhJ8+ZNZhQCObRjcFInSINOhAZtQBm9IDGVSYKYkvoWeg03Yj35oN8pFA5h",
	"iVjQg1zqlMTovCkYTmP6V6N1kJfOgyTu5Kg9iKr1wiiFNoiMOMqTe56Ono3eGefD4C5K+oakY0WOHkn5",
	"/WNbDlcZwvlLQkwlCm/AorcSV6SVJBViT6jyR0dBtiNyNn8ppSUHL+ieoDqHeZE/s69KMA7K5fuzs91J",
	"evvfNN9/CY8Soz0G2yOKQkXqTD+64LM0je/T6lGj37IZbjd1TnpDCwWXaFdooSpILlxSWunXLLyog//x",
	"8+340yjymv/8mXyoPBcUu1bgmq3hotRw/nI0Hv36NBGFmEnFNUXfmOuf1g8kuumnSl/fTj81b9wG2SgM",
	"KYDNrl9gboheQK8RPqu3YG5NDgIKa1YyxagKzl9O4CLMnGv0ZkYMpb+e5CaV8/Uz+vZJq7LJDtJecn9e",
	"tHr/Pvb9RTPUAfCLvQrA46FQP7aGEaDegcbavu3D447h6+oH1VIRodV63a3eLiTt4Q7vxCAKXG125ka4",
	"oFKcm5dsfbhr6e/Gk+ca2A8AkySltZgCeSN6MYH/NOkaMuHic4uuVH6yS6E2a8ZtRm1QqBfUu1xqAZbD",
	"tk59/zxNOxlCtvi3IkhQxfdID5Gmu+h8UGaINP0iaSHS9BGSohvEBxhBJqaJfRbYQY5o8yqz79hVCe/w",
	"nFMUA+SzfeO+DURw6Jk7a1Pu4v41+lehwe6pHDwZdw3UumaqHphFX1r9kCj5PHhsqckwZXFQYbaVWUyF",
	"9yLJpp+iE9w57T+x8lvIFZKTMoY5+6E032bBrq6ck0NLEUeptaQ4L1RLzJeei3CiCiwmKFdVCKKERwJM",
	"kGbwQqTvclZfo39jFs+50jv6qnXH58ZOuhXSvTut3519tyvVV86LmeI8JdzgzJlkif7r9GOf17MtKgiQ",
	"iHcVjjILx982A342sijSGpALTKXuReLfhZIpBbxxEheYPpUaQgazmnBSZxOoiroY17dDaxALIbULsbis",
	"JEGx60w48t/O561MgYstgdRjEPBfl2//B4IVohY/jAgfH0YhHJxRU9r/GILfG+konI1BtsWQTYDSqrp0",
	"IZzDlHUkKU6utPQkytk62FElUe8hRRDYHRXotm3dgcsrycF8PdiYSnl/8aaK/MMYk0wohXqBky9VXTbB",
	"V4bJspnakFyocbgHhH8VOlVYp4soeJdp7fdsywHOWTPKvDDWC81Ty8kjWwUwAZIfhQUx92hDcoHAQO/l",
	"IsUxiN3kkLCMT04I5EKLBdJ/68b9UsrRsLi25+/O+xHE8DmoUBOTIoR1bYZ4SHRw2gtupM/qVun7Mdxw",
	"79gsaH709nnps+8Bf00yoRdIb67abCZ9i863vMRfSrTrlpto0ntwUXmW4RsrdGpy+f+YRip/Sz3mcdWD",
	"MVYuJCkGJfUy5nykA0wyg2l7+M7Qy4nQMC8t80SmqL2crxt91DusALu7OL4/nH3fFewHZROyhiB0yMYV",
	"hBOpU+Ig1r5wBZqQ6JuXmt+bwE9GKXMTp2ejPs7jYaOIpabgiOqawHlVWUxaSgcfRtMPo3HIW+YodJVT",
	"3PTHSUhfutZ4YxZkMYLOc2vnMW/pjGlZLKxIsVd3cG44FgqWqUAbl8g2DBh8c5PJJANbBZi8hkWOB4mU",
	"XaWaVWQ0nPT4Lc80T1mzQwgEi3dMKGX5N6sCrbajFpFFSU5Z8zprGnLfCN2tN41GJoNYCcmrEfvUy/so",
	"lCG4vaozqzPsAl7QQF8pUoJuidOftqe+xlBc6OsEzwujV6jJHVBrSBQKu2MWJvB/pgzy0xiMQ2AaezwT",
	"eFll2vn1aKzCqkL/DFKf7l3nTL7qeIoml/y0yNi2ImhzZ5rIqUjT6Sdzo9HeTj/Rw/5A63Vcz3EgeLkF",
	"HCYWQwBVmMDNJtX0xLVpztCKwRaV4PffX7yZwAUHsA6+PzsDoyv5j+EvZ2fw5yiBHJ2jaSLdIqQqLY7J",
	"x5MxhGqaIaEJRS77GmaIOmRQaLpf9LkYFy2BvJDP0/QtCYO+PeR3sNTqOK7uBEWg1nkoKKQ088orafWS",
	"E1GuTDLynJ6glcvsCTki4eN0bsyTvmwUt3k3P6OdBmv3OniMidEpZELNqyKHuk+93ep8by7NBqnecxbt",
	"a11fCXkwV2Ai5zJpSzjgtTcjlkh+xK08dYkpatl2UjxFNZTi/0uqmShG3CJF3OJPRawfmwVRVliNvq+Z",
	"PYhqL1GdqHai2u9CtbAO43roxv7qfREuX/eyqzJ1Akj4brK5vzms4ijVoAVEtWjj4MZKj9FbBm8mh/j1",
	"t4OrMg6FTbIqVzRbQ3DpvYG5VB4rv8P1RYb8+ugzIHUvuNnaG94BoK8Vqz+hJ75HINC8UwSzGfS0NwtN",
	"OkBIAdEeGIrUbeokqlMxBqvQ7fm7c6g2Bo4BJ4vJGF6H6OYQ9C6p8cesTWiAW/NRic1ibjhCDZLrmppy",
	"dozTfVnO6M8ZcTQXS4zbq+ilJw54cyfwAhOIoiAbLDWsTWkhMznCSuLNMBe7ca0HGO/LcvYHcJQfotsn",
	"s71BtAh+jIs3jYirdZwX5z0UO8Lpfa9di2S2chX0GvBX6XgTZSxQhMRjXG64Eetx9JM5yTWzZom8Y9A2",
	"hJvA23qtpfWEqFfFwkzAYaz7A/jMJ9Y9NOsaPmC19651pLOTbqF0+rmer5lvOb7t5c2m+iF+72XTmZP/",
	"+1XCjxFBcGhNfBtvHQhcSd5G/psEXuRCHRF3/T125QS+RxB8bfj4tU4i758d64jEUm/s1O9DYNjfI3gz",
	"9c5G/eAXcBvzUikuFM6NgNSJKlOCieCCiqXnMlm4bjSW+mvcM38/wCz1Y0Lja/Rhz1IATI23/j2QtfKM",
	"c+rGYIqwKqrWUbdEjdNynXiRqfrrz5d/fT6Bd2IhdVjOJYFZo8KmjkNLqhfUuwPIK3bqfgY3FNXyWlx7",
	"N1zcncHab9KjC+mlDU1YX/ZyNuiY1pDeZeYm7F8JoTbfGuLIzxTc596uoX3X27vvzj6vf9V8/ri9+MUO",
	"sDewwLB1jG842dhIuNW9lld3nIu+0QOXiaNadZl4OMMVz90/Ih3xduZFpAkpClU5NJW5apTGtL7spmf9",
	"vtT+rnqjXylw9bua4W64fAh8Habso8HWJiQCkpoz9vu3Zbc8nuac/WHHp1X2M/2fpoZjfaBmaIddoS/a",
	"Ddq93eCRuURuC1Gd0IzHaA+ent0P0HhUNQakT4N5i6k7aZkY3Wem2jgMLd0FjUlVw++IxUd1jHUoaPa6",
	"151K7YkLp+f36TYV01xckDdDNW7mQS02xKd+QE02Pvn3d/DvT+7u0fq/he6GeN1sZnV9NJ2Dkh/C51Dy",
	"WEJfca9OjD4x+liS1VdSPV5Kt8i3zelBTK6o2RDO/V4Bxynz9ZtmvrbyXbxSzAtBfCAx7HbB9L6zXVWO",
	"y1iYWaHDKs3B1h4yy9V1dfBjWyCMSqF1PKWlJg5kulrKggtuaYt4EEz4JJy0C9mvQ9TvyW+dEHzKo8U8",
	"Wg9k/f7jeHxirl6R9gaK0mUg4KOZgdTOo0gJv/Qt31zAh9BoqueSz2sLKEo2Y3yAlc9DW7lYoA11VCeA",
	"63UdMMHyeKnXL87h/TknO168Od9/1vsyDOWO+Pfo/ED832GLUR8fQut76XCHVi9KHVbm0HnXnjqLas0n",
	"6zWkcj4Hh6o5plbIZEnzkfcJRSjVRdPmYu0vLblzTwfe+u+XeYeWdAsIclxKobZipwDs3b3+kYxMzP1h",
	"41W9zMW+pq13l1SuJ3np0ZuM1iQxNkxCWt1IEDw7eCWSLHyGXKzZ7xJSt4LJSOW4/mJLFS4rVDKXnu8p",
	"jLPlKiY7b41e8KVaiclz1Gl10tIsqxseP4zY8H0YAeF5JRRVUC0bOQTUKV+R6upzuWtT8saH5ha/Vhdz",
	"YxEcPVr3qIdBEe/JOz6tCz+Mx/wYw+rWwjDJPiqnw4u6fKA+E5OWJqwvJD3iMlIXb6Xjtjma77nmk1VD",
	"ePfYBTuu+8GW6h7bLZ9stQ5d8xnxsDe+agwwZ1jqGCuogHjNRlQLcbtjYiWBUVQXS5CpmSHoaj/ktwzL",
	"mLuRnlRsnJ99BmdQTNZorfaRwLbV/c3UJKnIIS2dQrHfYEtDcElaoOY9Mnv3NFwFn6Os8v9a1R6bewZ/",
	"AufL+Rz+FO+W/ljq5R5wXpTaHVZ4fkPh8Q8MnHL+p1W8R7hpbSYcpnX2IdiiSSc/D5if19G01HaHvZGe",
	"MKxqqD4kSTHOYcsSyDs457fJ4MkXuqXoD7uzrYWLmEPrw+CAs05XzQV5VazsCNwy2YjqVxj2aKL20sbG",
	"EmOLMkKVL350nEHg5WU+1Ns+h8is4aB/NwHBnd2H3+HHpE5m4LT0+3vYgc0dFUyBGSoT6LhxEGdtSj6K",
	"sHUwMLC0+nWZvp8Z4IvA8VcPr19dQSge9/nxL3mBAI03YDROoLns7WPJaT6+y737CuDwKwJX3PrXHi12",
	"3mDP0ZdDH/RQXByoj8XRq7fjPfow/BoJX/5H01fqOXqPfMd4VUf7JjrhQjthzaPKP9ZrGKSc48z5rE/N",
	"7ZmL+7t5tvIaWl3i+LVKlxbCRdUzQ2F5AYcKSQ0ZihRtyJJUF3PGAfIbvGOhupzz4XLzR9w6F7bmdkKD",
	"qEljmW79Vmuf+yZ10LWk18WMrxwmhy5cN8VSGddHvauDDqTGe7Dw3qFt/cjUHUFxxA9XdUo4bjOJgSM5",
	"HAzzRjRf7vWRxy/GDJvN0LWBBuT2nwEAAP//lzheNzt8AAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.Swagger, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewSwaggerLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.SwaggerLoader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadSwaggerFromData(specData)
	if err != nil {
		return
	}
	return
}
