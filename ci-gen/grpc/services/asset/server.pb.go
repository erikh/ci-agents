// Code generated by protoc-gen-go. DO NOT EDIT.
// source: grpc/services/asset/server.proto

package asset

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	types "github.com/tinyci/ci-agents/ci-gen/grpc/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Sending type
type LogSend struct {
	ID                   int64    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Chunk                []byte   `protobuf:"bytes,2,opt,name=Chunk,proto3" json:"Chunk,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LogSend) Reset()         { *m = LogSend{} }
func (m *LogSend) String() string { return proto.CompactTextString(m) }
func (*LogSend) ProtoMessage()    {}
func (*LogSend) Descriptor() ([]byte, []int) {
	return fileDescriptor_a1c0c110bd3c7d6d, []int{0}
}

func (m *LogSend) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LogSend.Unmarshal(m, b)
}
func (m *LogSend) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LogSend.Marshal(b, m, deterministic)
}
func (m *LogSend) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogSend.Merge(m, src)
}
func (m *LogSend) XXX_Size() int {
	return xxx_messageInfo_LogSend.Size(m)
}
func (m *LogSend) XXX_DiscardUnknown() {
	xxx_messageInfo_LogSend.DiscardUnknown(m)
}

var xxx_messageInfo_LogSend proto.InternalMessageInfo

func (m *LogSend) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *LogSend) GetChunk() []byte {
	if m != nil {
		return m.Chunk
	}
	return nil
}

// Receive type
type LogChunk struct {
	Chunk                []byte   `protobuf:"bytes,1,opt,name=Chunk,proto3" json:"Chunk,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LogChunk) Reset()         { *m = LogChunk{} }
func (m *LogChunk) String() string { return proto.CompactTextString(m) }
func (*LogChunk) ProtoMessage()    {}
func (*LogChunk) Descriptor() ([]byte, []int) {
	return fileDescriptor_a1c0c110bd3c7d6d, []int{1}
}

func (m *LogChunk) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LogChunk.Unmarshal(m, b)
}
func (m *LogChunk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LogChunk.Marshal(b, m, deterministic)
}
func (m *LogChunk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogChunk.Merge(m, src)
}
func (m *LogChunk) XXX_Size() int {
	return xxx_messageInfo_LogChunk.Size(m)
}
func (m *LogChunk) XXX_DiscardUnknown() {
	xxx_messageInfo_LogChunk.DiscardUnknown(m)
}

var xxx_messageInfo_LogChunk proto.InternalMessageInfo

func (m *LogChunk) GetChunk() []byte {
	if m != nil {
		return m.Chunk
	}
	return nil
}

func init() {
	proto.RegisterType((*LogSend)(nil), "LogSend")
	proto.RegisterType((*LogChunk)(nil), "LogChunk")
}

func init() { proto.RegisterFile("grpc/services/asset/server.proto", fileDescriptor_a1c0c110bd3c7d6d) }

var fileDescriptor_a1c0c110bd3c7d6d = []byte{
	// 260 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x90, 0xc1, 0x4b, 0xc3, 0x30,
	0x14, 0xc6, 0x49, 0x65, 0x75, 0x86, 0xe1, 0x21, 0x88, 0x8c, 0x9e, 0xca, 0xbc, 0xf4, 0xa0, 0x89,
	0x38, 0x10, 0xaf, 0x6a, 0x45, 0x0a, 0x3d, 0xc8, 0xbc, 0xed, 0xd6, 0x66, 0xcf, 0xb7, 0xe0, 0x96,
	0x84, 0x26, 0x15, 0xfa, 0xdf, 0x4b, 0xd3, 0x0d, 0xeb, 0x6d, 0x97, 0xf0, 0x3e, 0xf2, 0x7d, 0xf9,
	0xf2, 0x7b, 0x34, 0xc5, 0xc6, 0x4a, 0xe1, 0xa0, 0xf9, 0x51, 0x12, 0x9c, 0xa8, 0x9c, 0x03, 0x1f,
	0x24, 0x34, 0xdc, 0x36, 0xc6, 0x9b, 0x64, 0x89, 0xca, 0x6f, 0xdb, 0x9a, 0x4b, 0xb3, 0x17, 0x68,
	0x76, 0x95, 0x46, 0x11, 0x2e, 0xea, 0xf6, 0x4b, 0x58, 0xdf, 0x59, 0x70, 0x02, 0xf6, 0xd6, 0x77,
	0xc3, 0x79, 0x08, 0x3d, 0x8e, 0x42, 0x5e, 0xe9, 0x4e, 0x2a, 0x21, 0xd5, 0x5d, 0x85, 0xa0, 0xbd,
	0xeb, 0x27, 0x04, 0x2d, 0x42, 0xf3, 0xf0, 0x80, 0xda, 0x0c, 0xb9, 0x85, 0xa0, 0xe7, 0xa5, 0xc1,
	0x4f, 0xd0, 0x1b, 0x76, 0x49, 0xa3, 0x22, 0x9f, 0x93, 0x94, 0x64, 0x67, 0xab, 0xa8, 0xc8, 0xd9,
	0x15, 0x9d, 0xbc, 0x6e, 0x5b, 0xfd, 0x3d, 0x8f, 0x52, 0x92, 0xcd, 0x56, 0x83, 0x58, 0xa4, 0x74,
	0x5a, 0x1a, 0x0c, 0xf3, 0x9f, 0x83, 0x8c, 0x1c, 0x0f, 0x6b, 0x3a, 0x79, 0xee, 0xa9, 0xd8, 0x2d,
	0x8d, 0x3f, 0x5a, 0x5f, 0x1a, 0x64, 0x53, 0x7e, 0x28, 0x49, 0xae, 0x39, 0x1a, 0x83, 0x3b, 0xe0,
	0x47, 0x24, 0xfe, 0xd6, 0x53, 0x64, 0x84, 0xdd, 0xd0, 0xf8, 0x1d, 0x82, 0x7b, 0xc6, 0xc3, 0x27,
	0x79, 0xa1, 0x7d, 0x91, 0x27, 0x17, 0xfc, 0xd8, 0x77, 0x4f, 0x5e, 0x9e, 0xd6, 0x27, 0x83, 0xfe,
	0x5f, 0x71, 0x1d, 0x87, 0xc2, 0xe5, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xb0, 0xe9, 0x58, 0x3b,
	0x80, 0x01, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// AssetClient is the client API for Asset service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AssetClient interface {
	PutLog(ctx context.Context, opts ...grpc.CallOption) (Asset_PutLogClient, error)
	GetLog(ctx context.Context, in *types.IntID, opts ...grpc.CallOption) (Asset_GetLogClient, error)
}

type assetClient struct {
	cc *grpc.ClientConn
}

func NewAssetClient(cc *grpc.ClientConn) AssetClient {
	return &assetClient{cc}
}

func (c *assetClient) PutLog(ctx context.Context, opts ...grpc.CallOption) (Asset_PutLogClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Asset_serviceDesc.Streams[0], "/Asset/PutLog", opts...)
	if err != nil {
		return nil, err
	}
	x := &assetPutLogClient{stream}
	return x, nil
}

type Asset_PutLogClient interface {
	Send(*LogSend) error
	CloseAndRecv() (*empty.Empty, error)
	grpc.ClientStream
}

type assetPutLogClient struct {
	grpc.ClientStream
}

func (x *assetPutLogClient) Send(m *LogSend) error {
	return x.ClientStream.SendMsg(m)
}

func (x *assetPutLogClient) CloseAndRecv() (*empty.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(empty.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *assetClient) GetLog(ctx context.Context, in *types.IntID, opts ...grpc.CallOption) (Asset_GetLogClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Asset_serviceDesc.Streams[1], "/Asset/GetLog", opts...)
	if err != nil {
		return nil, err
	}
	x := &assetGetLogClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Asset_GetLogClient interface {
	Recv() (*LogChunk, error)
	grpc.ClientStream
}

type assetGetLogClient struct {
	grpc.ClientStream
}

func (x *assetGetLogClient) Recv() (*LogChunk, error) {
	m := new(LogChunk)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// AssetServer is the server API for Asset service.
type AssetServer interface {
	PutLog(Asset_PutLogServer) error
	GetLog(*types.IntID, Asset_GetLogServer) error
}

// UnimplementedAssetServer can be embedded to have forward compatible implementations.
type UnimplementedAssetServer struct {
}

func (*UnimplementedAssetServer) PutLog(srv Asset_PutLogServer) error {
	return status.Errorf(codes.Unimplemented, "method PutLog not implemented")
}
func (*UnimplementedAssetServer) GetLog(req *types.IntID, srv Asset_GetLogServer) error {
	return status.Errorf(codes.Unimplemented, "method GetLog not implemented")
}

func RegisterAssetServer(s *grpc.Server, srv AssetServer) {
	s.RegisterService(&_Asset_serviceDesc, srv)
}

func _Asset_PutLog_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AssetServer).PutLog(&assetPutLogServer{stream})
}

type Asset_PutLogServer interface {
	SendAndClose(*empty.Empty) error
	Recv() (*LogSend, error)
	grpc.ServerStream
}

type assetPutLogServer struct {
	grpc.ServerStream
}

func (x *assetPutLogServer) SendAndClose(m *empty.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *assetPutLogServer) Recv() (*LogSend, error) {
	m := new(LogSend)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Asset_GetLog_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(types.IntID)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AssetServer).GetLog(m, &assetGetLogServer{stream})
}

type Asset_GetLogServer interface {
	Send(*LogChunk) error
	grpc.ServerStream
}

type assetGetLogServer struct {
	grpc.ServerStream
}

func (x *assetGetLogServer) Send(m *LogChunk) error {
	return x.ServerStream.SendMsg(m)
}

var _Asset_serviceDesc = grpc.ServiceDesc{
	ServiceName: "Asset",
	HandlerType: (*AssetServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "PutLog",
			Handler:       _Asset_PutLog_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "GetLog",
			Handler:       _Asset_GetLog_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "grpc/services/asset/server.proto",
}
