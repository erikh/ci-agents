// tslint:disable
/**
 * uisvc
 * API for the user interface service; the service that is directly responsible for presenting data to users. This service typically runs at the border, and leverages session cookies or authentication tokens that we generate for users. It also is responsible for handling the act of oauth and user creation through its login hooks. uisvc typically talks to the datasvc and other services to accomplish its goal, it does not save anything locally or carry state. 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    Repository,
    RepositoryFromJSON,
    RepositoryToJSON,
    Run,
    RunFromJSON,
    RunToJSON,
    Task,
    TaskFromJSON,
    TaskToJSON,
    UserError,
    UserErrorFromJSON,
    UserErrorToJSON,
} from '../models';

export interface CancelRunIdPostRequest {
    runId: number;
}

export interface CapabilitiesUsernameCapabilityDeleteRequest {
    username: string;
    capability: string;
}

export interface CapabilitiesUsernameCapabilityPostRequest {
    username: string;
    capability: string;
}

export interface LogAttachIdGetRequest {
    id: number;
}

export interface LoginGetRequest {
    code: string;
    state: string;
}

export interface RepositoriesCiAddOwnerRepoGetRequest {
    owner: string;
    repo: string;
}

export interface RepositoriesCiDelOwnerRepoGetRequest {
    owner: string;
    repo: string;
}

export interface RepositoriesMyGetRequest {
    search?: string;
}

export interface RepositoriesSubAddOwnerRepoGetRequest {
    owner: string;
    repo: string;
}

export interface RepositoriesSubDelOwnerRepoGetRequest {
    owner: string;
    repo: string;
}

export interface RepositoriesSubscribedGetRequest {
    search?: string;
}

export interface RepositoriesVisibleGetRequest {
    search?: string;
}

export interface RunRunIdGetRequest {
    runId: number;
}

export interface RunsCountGetRequest {
    repository?: string;
    sha?: string;
}

export interface RunsGetRequest {
    page?: number;
    perPage?: number;
    repository?: string;
    sha?: string;
}

export interface SubmitGetRequest {
    repository: string;
    sha: string;
    all?: boolean;
}

export interface TasksCountGetRequest {
    repository?: string;
    sha?: string;
}

export interface TasksGetRequest {
    page?: number;
    perPage?: number;
    repository?: string;
    sha?: string;
}

export interface TasksRunsIdCountGetRequest {
    id: number;
}

export interface TasksRunsIdGetRequest {
    id: number;
    page?: number;
    perPage?: number;
}

export interface TasksSubscribedGetRequest {
    page?: number;
    perPage?: number;
}

/**
 * no description
 */
export class DefaultApi extends runtime.BaseAPI {

    /**
     * Cancel the run by ID; this will actually trickle back and cancel the whole task, since it can no longer succeed in any way. Please keep in mind to stop runs, runners must implement a cancel poller. 
     * Cancel by Run ID
     */
    async cancelRunIdPostRaw(requestParameters: CancelRunIdPostRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.runId === null || requestParameters.runId === undefined) {
            throw new runtime.RequiredError('runId','Required parameter requestParameters.runId was null or undefined when calling cancelRunIdPost.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Cookie"] = this.configuration.apiKey("Cookie"); // session authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // token authentication
        }

        const response = await this.request({
            path: `/cancel/{run_id}`.replace(`{${"run_id"}}`, encodeURIComponent(String(requestParameters.runId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Cancel the run by ID; this will actually trickle back and cancel the whole task, since it can no longer succeed in any way. Please keep in mind to stop runs, runners must implement a cancel poller. 
     * Cancel by Run ID
     */
    async cancelRunIdPost(requestParameters: CancelRunIdPostRequest): Promise<void> {
        await this.cancelRunIdPostRaw(requestParameters);
    }

    /**
     * Remove a named capability from a provided user ID. Requires the user have the \'modify:user\' capability.
     * Remove a named capability
     */
    async capabilitiesUsernameCapabilityDeleteRaw(requestParameters: CapabilitiesUsernameCapabilityDeleteRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.username === null || requestParameters.username === undefined) {
            throw new runtime.RequiredError('username','Required parameter requestParameters.username was null or undefined when calling capabilitiesUsernameCapabilityDelete.');
        }

        if (requestParameters.capability === null || requestParameters.capability === undefined) {
            throw new runtime.RequiredError('capability','Required parameter requestParameters.capability was null or undefined when calling capabilitiesUsernameCapabilityDelete.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Cookie"] = this.configuration.apiKey("Cookie"); // session authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // token authentication
        }

        const response = await this.request({
            path: `/capabilities/{username}/{capability}`.replace(`{${"username"}}`, encodeURIComponent(String(requestParameters.username))).replace(`{${"capability"}}`, encodeURIComponent(String(requestParameters.capability))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove a named capability from a provided user ID. Requires the user have the \'modify:user\' capability.
     * Remove a named capability
     */
    async capabilitiesUsernameCapabilityDelete(requestParameters: CapabilitiesUsernameCapabilityDeleteRequest): Promise<void> {
        await this.capabilitiesUsernameCapabilityDeleteRaw(requestParameters);
    }

    /**
     * Add a named capability for a provided user ID. Requires the user have the \'modify:user\' capability.
     * Add a named capability
     */
    async capabilitiesUsernameCapabilityPostRaw(requestParameters: CapabilitiesUsernameCapabilityPostRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.username === null || requestParameters.username === undefined) {
            throw new runtime.RequiredError('username','Required parameter requestParameters.username was null or undefined when calling capabilitiesUsernameCapabilityPost.');
        }

        if (requestParameters.capability === null || requestParameters.capability === undefined) {
            throw new runtime.RequiredError('capability','Required parameter requestParameters.capability was null or undefined when calling capabilitiesUsernameCapabilityPost.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Cookie"] = this.configuration.apiKey("Cookie"); // session authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // token authentication
        }

        const response = await this.request({
            path: `/capabilities/{username}/{capability}`.replace(`{${"username"}}`, encodeURIComponent(String(requestParameters.username))).replace(`{${"capability"}}`, encodeURIComponent(String(requestParameters.capability))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Add a named capability for a provided user ID. Requires the user have the \'modify:user\' capability.
     * Add a named capability
     */
    async capabilitiesUsernameCapabilityPost(requestParameters: CapabilitiesUsernameCapabilityPostRequest): Promise<void> {
        await this.capabilitiesUsernameCapabilityPostRaw(requestParameters);
    }

    /**
     * Server retrieves any errors the last call(s) have set for you.
     * Retrieve errors
     */
    async errorsGetRaw(): Promise<runtime.ApiResponse<Array<UserError>>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Cookie"] = this.configuration.apiKey("Cookie"); // session authentication
        }

        const response = await this.request({
            path: `/errors`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UserErrorFromJSON));
    }

    /**
     * Server retrieves any errors the last call(s) have set for you.
     * Retrieve errors
     */
    async errorsGet(): Promise<Array<UserError>> {
        const response = await this.errorsGetRaw();
        return await response.value();
    }

    /**
     * For a given ID, find the log and if it is running, attach to it and start receiving the latest content from it. 
     * Attach to a running log
     */
    async logAttachIdGetRaw(requestParameters: LogAttachIdGetRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling logAttachIdGet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Cookie"] = this.configuration.apiKey("Cookie"); // session authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // token authentication
        }

        const response = await this.request({
            path: `/log/attach/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * For a given ID, find the log and if it is running, attach to it and start receiving the latest content from it. 
     * Attach to a running log
     */
    async logAttachIdGet(requestParameters: LogAttachIdGetRequest): Promise<void> {
        await this.logAttachIdGetRaw(requestParameters);
    }

    /**
     * Validate the logged-in status of the user. Validates the session cookie against the internal database. If the user is logged in, a JSON string of \"true\" will be sent; otherwise an oauth redirect url will be passed for calling out to by the client. 
     * Check logged in state
     */
    async loggedinGetRaw(): Promise<runtime.ApiResponse<string>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/loggedin`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Validate the logged-in status of the user. Validates the session cookie against the internal database. If the user is logged in, a JSON string of \"true\" will be sent; otherwise an oauth redirect url will be passed for calling out to by the client. 
     * Check logged in state
     */
    async loggedinGet(): Promise<string> {
        const response = await this.loggedinGetRaw();
        return await response.value();
    }

    /**
     * Handle the server side of the oauth challenge. It is important to preserve the cookie jar after this call is made, as session cookies are used to manage many of the calls in this API. 
     * Log into the system
     */
    async loginGetRaw(requestParameters: LoginGetRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.code === null || requestParameters.code === undefined) {
            throw new runtime.RequiredError('code','Required parameter requestParameters.code was null or undefined when calling loginGet.');
        }

        if (requestParameters.state === null || requestParameters.state === undefined) {
            throw new runtime.RequiredError('state','Required parameter requestParameters.state was null or undefined when calling loginGet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.code !== undefined) {
            queryParameters['code'] = requestParameters.code;
        }

        if (requestParameters.state !== undefined) {
            queryParameters['state'] = requestParameters.state;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/login`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Handle the server side of the oauth challenge. It is important to preserve the cookie jar after this call is made, as session cookies are used to manage many of the calls in this API. 
     * Log into the system
     */
    async loginGet(requestParameters: LoginGetRequest): Promise<void> {
        await this.loginGetRaw(requestParameters);
    }

    /**
     * This upgrades the permissions of the user (which requires confirmation from the OAuthing site) to allow repository access, so that additional permission to manipulate repositories and scan additional ones is available. 
     * Log into the system with upgraded permissions
     */
    async loginUpgradeGetRaw(): Promise<runtime.ApiResponse<void>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/login/upgrade`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This upgrades the permissions of the user (which requires confirmation from the OAuthing site) to allow repository access, so that additional permission to manipulate repositories and scan additional ones is available. 
     * Log into the system with upgraded permissions
     */
    async loginUpgradeGet(): Promise<void> {
        await this.loginUpgradeGetRaw();
    }

    /**
     * Conveniently clears session cookies. You will need to login again. Does not clear oauth tokens. 
     * Log out of the system
     */
    async logoutGetRaw(): Promise<runtime.ApiResponse<void>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Cookie"] = this.configuration.apiKey("Cookie"); // session authentication
        }

        const response = await this.request({
            path: `/logout`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Conveniently clears session cookies. You will need to login again. Does not clear oauth tokens. 
     * Log out of the system
     */
    async logoutGet(): Promise<void> {
        await this.logoutGetRaw();
    }

    /**
     * Generates a hook secret and populates the user\'s repository with it and the hook URL. Returns 200 on success, 500 + error message on failure, or if the repository has already been added to CI. 
     * Add a specific repository to CI.
     */
    async repositoriesCiAddOwnerRepoGetRaw(requestParameters: RepositoriesCiAddOwnerRepoGetRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.owner === null || requestParameters.owner === undefined) {
            throw new runtime.RequiredError('owner','Required parameter requestParameters.owner was null or undefined when calling repositoriesCiAddOwnerRepoGet.');
        }

        if (requestParameters.repo === null || requestParameters.repo === undefined) {
            throw new runtime.RequiredError('repo','Required parameter requestParameters.repo was null or undefined when calling repositoriesCiAddOwnerRepoGet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Cookie"] = this.configuration.apiKey("Cookie"); // session authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // token authentication
        }

        const response = await this.request({
            path: `/repositories/ci/add/{owner}/{repo}`.replace(`{${"owner"}}`, encodeURIComponent(String(requestParameters.owner))).replace(`{${"repo"}}`, encodeURIComponent(String(requestParameters.repo))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Generates a hook secret and populates the user\'s repository with it and the hook URL. Returns 200 on success, 500 + error message on failure, or if the repository has already been added to CI. 
     * Add a specific repository to CI.
     */
    async repositoriesCiAddOwnerRepoGet(requestParameters: RepositoriesCiAddOwnerRepoGetRequest): Promise<void> {
        await this.repositoriesCiAddOwnerRepoGetRaw(requestParameters);
    }

    /**
     * Will fail if not added to CI already; does not currently clear the hook. 
     * Removes a specific repository from CI.
     */
    async repositoriesCiDelOwnerRepoGetRaw(requestParameters: RepositoriesCiDelOwnerRepoGetRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.owner === null || requestParameters.owner === undefined) {
            throw new runtime.RequiredError('owner','Required parameter requestParameters.owner was null or undefined when calling repositoriesCiDelOwnerRepoGet.');
        }

        if (requestParameters.repo === null || requestParameters.repo === undefined) {
            throw new runtime.RequiredError('repo','Required parameter requestParameters.repo was null or undefined when calling repositoriesCiDelOwnerRepoGet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Cookie"] = this.configuration.apiKey("Cookie"); // session authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // token authentication
        }

        const response = await this.request({
            path: `/repositories/ci/del/{owner}/{repo}`.replace(`{${"owner"}}`, encodeURIComponent(String(requestParameters.owner))).replace(`{${"repo"}}`, encodeURIComponent(String(requestParameters.repo))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Will fail if not added to CI already; does not currently clear the hook. 
     * Removes a specific repository from CI.
     */
    async repositoriesCiDelOwnerRepoGet(requestParameters: RepositoriesCiDelOwnerRepoGetRequest): Promise<void> {
        await this.repositoriesCiDelOwnerRepoGetRaw(requestParameters);
    }

    /**
     * Returns a types.RepositoryList for all the repos a user has write access to.
     * Fetch all the writable repositories for the user.
     */
    async repositoriesMyGetRaw(requestParameters: RepositoriesMyGetRequest): Promise<runtime.ApiResponse<Array<Repository>>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Cookie"] = this.configuration.apiKey("Cookie"); // session authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // token authentication
        }

        const response = await this.request({
            path: `/repositories/my`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(RepositoryFromJSON));
    }

    /**
     * Returns a types.RepositoryList for all the repos a user has write access to.
     * Fetch all the writable repositories for the user.
     */
    async repositoriesMyGet(requestParameters: RepositoriesMyGetRequest): Promise<Array<Repository>> {
        const response = await this.repositoriesMyGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Subscribing makes that repo\'s queue items appear in your home view. Returns 200 on success, 500 + error on failure. 
     * Subscribe to a repository running CI
     */
    async repositoriesSubAddOwnerRepoGetRaw(requestParameters: RepositoriesSubAddOwnerRepoGetRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.owner === null || requestParameters.owner === undefined) {
            throw new runtime.RequiredError('owner','Required parameter requestParameters.owner was null or undefined when calling repositoriesSubAddOwnerRepoGet.');
        }

        if (requestParameters.repo === null || requestParameters.repo === undefined) {
            throw new runtime.RequiredError('repo','Required parameter requestParameters.repo was null or undefined when calling repositoriesSubAddOwnerRepoGet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Cookie"] = this.configuration.apiKey("Cookie"); // session authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // token authentication
        }

        const response = await this.request({
            path: `/repositories/sub/add/{owner}/{repo}`.replace(`{${"owner"}}`, encodeURIComponent(String(requestParameters.owner))).replace(`{${"repo"}}`, encodeURIComponent(String(requestParameters.repo))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Subscribing makes that repo\'s queue items appear in your home view. Returns 200 on success, 500 + error on failure. 
     * Subscribe to a repository running CI
     */
    async repositoriesSubAddOwnerRepoGet(requestParameters: RepositoriesSubAddOwnerRepoGetRequest): Promise<void> {
        await this.repositoriesSubAddOwnerRepoGetRaw(requestParameters);
    }

    /**
     * Unsubscribing removes any existing subscription. Either way, if nothing broke, it returns 200. Otherwise it returns 500 and the error. 
     * Unsubscribe from a repository
     */
    async repositoriesSubDelOwnerRepoGetRaw(requestParameters: RepositoriesSubDelOwnerRepoGetRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.owner === null || requestParameters.owner === undefined) {
            throw new runtime.RequiredError('owner','Required parameter requestParameters.owner was null or undefined when calling repositoriesSubDelOwnerRepoGet.');
        }

        if (requestParameters.repo === null || requestParameters.repo === undefined) {
            throw new runtime.RequiredError('repo','Required parameter requestParameters.repo was null or undefined when calling repositoriesSubDelOwnerRepoGet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Cookie"] = this.configuration.apiKey("Cookie"); // session authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // token authentication
        }

        const response = await this.request({
            path: `/repositories/sub/del/{owner}/{repo}`.replace(`{${"owner"}}`, encodeURIComponent(String(requestParameters.owner))).replace(`{${"repo"}}`, encodeURIComponent(String(requestParameters.repo))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Unsubscribing removes any existing subscription. Either way, if nothing broke, it returns 200. Otherwise it returns 500 and the error. 
     * Unsubscribe from a repository
     */
    async repositoriesSubDelOwnerRepoGet(requestParameters: RepositoriesSubDelOwnerRepoGetRequest): Promise<void> {
        await this.repositoriesSubDelOwnerRepoGetRaw(requestParameters);
    }

    /**
     * Returns a types.RepositoryList of all the repos the user is subscribed to.
     * List all subscribed repositories
     */
    async repositoriesSubscribedGetRaw(requestParameters: RepositoriesSubscribedGetRequest): Promise<runtime.ApiResponse<Array<Repository>>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Cookie"] = this.configuration.apiKey("Cookie"); // session authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // token authentication
        }

        const response = await this.request({
            path: `/repositories/subscribed`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(RepositoryFromJSON));
    }

    /**
     * Returns a types.RepositoryList of all the repos the user is subscribed to.
     * List all subscribed repositories
     */
    async repositoriesSubscribedGet(requestParameters: RepositoriesSubscribedGetRequest): Promise<Array<Repository>> {
        const response = await this.repositoriesSubscribedGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns a types.RepositoryList for all the repos a user has view access to.
     * Fetch all the repositories the user can view.
     */
    async repositoriesVisibleGetRaw(requestParameters: RepositoriesVisibleGetRequest): Promise<runtime.ApiResponse<Array<Repository>>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Cookie"] = this.configuration.apiKey("Cookie"); // session authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // token authentication
        }

        const response = await this.request({
            path: `/repositories/visible`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(RepositoryFromJSON));
    }

    /**
     * Returns a types.RepositoryList for all the repos a user has view access to.
     * Fetch all the repositories the user can view.
     */
    async repositoriesVisibleGet(requestParameters: RepositoriesVisibleGetRequest): Promise<Array<Repository>> {
        const response = await this.repositoriesVisibleGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve a Run by ID; this will return the full Run object including all relationships.
     * Get a run by ID
     */
    async runRunIdGetRaw(requestParameters: RunRunIdGetRequest): Promise<runtime.ApiResponse<Run>> {
        if (requestParameters.runId === null || requestParameters.runId === undefined) {
            throw new runtime.RequiredError('runId','Required parameter requestParameters.runId was null or undefined when calling runRunIdGet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Cookie"] = this.configuration.apiKey("Cookie"); // session authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // token authentication
        }

        const response = await this.request({
            path: `/run/{run_id}`.replace(`{${"run_id"}}`, encodeURIComponent(String(requestParameters.runId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RunFromJSON(jsonValue));
    }

    /**
     * Retrieve a Run by ID; this will return the full Run object including all relationships.
     * Get a run by ID
     */
    async runRunIdGet(requestParameters: RunRunIdGetRequest): Promise<Run> {
        const response = await this.runRunIdGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Count the runs, optionally filtering by repository or repository+SHA. 
     * Count the runs
     */
    async runsCountGetRaw(requestParameters: RunsCountGetRequest): Promise<runtime.ApiResponse<number>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.repository !== undefined) {
            queryParameters['repository'] = requestParameters.repository;
        }

        if (requestParameters.sha !== undefined) {
            queryParameters['sha'] = requestParameters.sha;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Cookie"] = this.configuration.apiKey("Cookie"); // session authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // token authentication
        }

        const response = await this.request({
            path: `/runs/count`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Count the runs, optionally filtering by repository or repository+SHA. 
     * Count the runs
     */
    async runsCountGet(requestParameters: RunsCountGetRequest): Promise<number> {
        const response = await this.runsCountGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * List all the runs, optionally filtering by repository or repository+SHA. Pagination controls are available. 
     * Obtain the run list for the user
     */
    async runsGetRaw(requestParameters: RunsGetRequest): Promise<runtime.ApiResponse<Array<Run>>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.perPage !== undefined) {
            queryParameters['perPage'] = requestParameters.perPage;
        }

        if (requestParameters.repository !== undefined) {
            queryParameters['repository'] = requestParameters.repository;
        }

        if (requestParameters.sha !== undefined) {
            queryParameters['sha'] = requestParameters.sha;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Cookie"] = this.configuration.apiKey("Cookie"); // session authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // token authentication
        }

        const response = await this.request({
            path: `/runs`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(RunFromJSON));
    }

    /**
     * List all the runs, optionally filtering by repository or repository+SHA. Pagination controls are available. 
     * Obtain the run list for the user
     */
    async runsGet(requestParameters: RunsGetRequest): Promise<Array<Run>> {
        const response = await this.runsGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * This allows a user to push a job instead of pushing to git or filing a pull request to trigger a job. It is available on the tinyCI UI and CLI client. 
     * Perform a manual submission to tinyCI
     */
    async submitGetRaw(requestParameters: SubmitGetRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.repository === null || requestParameters.repository === undefined) {
            throw new runtime.RequiredError('repository','Required parameter requestParameters.repository was null or undefined when calling submitGet.');
        }

        if (requestParameters.sha === null || requestParameters.sha === undefined) {
            throw new runtime.RequiredError('sha','Required parameter requestParameters.sha was null or undefined when calling submitGet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.repository !== undefined) {
            queryParameters['repository'] = requestParameters.repository;
        }

        if (requestParameters.sha !== undefined) {
            queryParameters['sha'] = requestParameters.sha;
        }

        if (requestParameters.all !== undefined) {
            queryParameters['all'] = requestParameters.all;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Cookie"] = this.configuration.apiKey("Cookie"); // session authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // token authentication
        }

        const response = await this.request({
            path: `/submit`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This allows a user to push a job instead of pushing to git or filing a pull request to trigger a job. It is available on the tinyCI UI and CLI client. 
     * Perform a manual submission to tinyCI
     */
    async submitGet(requestParameters: SubmitGetRequest): Promise<void> {
        await this.submitGetRaw(requestParameters);
    }

    /**
     * Perform a full count of tasks that meet the filter criteria (which can be no filter) and return it as integer. 
     * Count the Tasks
     */
    async tasksCountGetRaw(requestParameters: TasksCountGetRequest): Promise<runtime.ApiResponse<number>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.repository !== undefined) {
            queryParameters['repository'] = requestParameters.repository;
        }

        if (requestParameters.sha !== undefined) {
            queryParameters['sha'] = requestParameters.sha;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Cookie"] = this.configuration.apiKey("Cookie"); // session authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // token authentication
        }

        const response = await this.request({
            path: `/tasks/count`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Perform a full count of tasks that meet the filter criteria (which can be no filter) and return it as integer. 
     * Count the Tasks
     */
    async tasksCountGet(requestParameters: TasksCountGetRequest): Promise<number> {
        const response = await this.tasksCountGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * The tasks list returns a list of Task objects that correspond to the query. Each query may contain pagination or filtering rules to limit its contents. It is strongly recommended to look at the \"count\" equivalents for these endpoints so that you can implement pagination more simply. 
     * Obtain the task list optionally filtering by repository and sha.
     */
    async tasksGetRaw(requestParameters: TasksGetRequest): Promise<runtime.ApiResponse<Array<Task>>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.perPage !== undefined) {
            queryParameters['perPage'] = requestParameters.perPage;
        }

        if (requestParameters.repository !== undefined) {
            queryParameters['repository'] = requestParameters.repository;
        }

        if (requestParameters.sha !== undefined) {
            queryParameters['sha'] = requestParameters.sha;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Cookie"] = this.configuration.apiKey("Cookie"); // session authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // token authentication
        }

        const response = await this.request({
            path: `/tasks`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TaskFromJSON));
    }

    /**
     * The tasks list returns a list of Task objects that correspond to the query. Each query may contain pagination or filtering rules to limit its contents. It is strongly recommended to look at the \"count\" equivalents for these endpoints so that you can implement pagination more simply. 
     * Obtain the task list optionally filtering by repository and sha.
     */
    async tasksGet(requestParameters: TasksGetRequest): Promise<Array<Task>> {
        const response = await this.tasksGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get the count of runs that correspond to the task ID. Returns an integer. 
     * Count the runs corresponding to the task ID.
     */
    async tasksRunsIdCountGetRaw(requestParameters: TasksRunsIdCountGetRequest): Promise<runtime.ApiResponse<number>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling tasksRunsIdCountGet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Cookie"] = this.configuration.apiKey("Cookie"); // session authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // token authentication
        }

        const response = await this.request({
            path: `/tasks/runs/{id}/count`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Get the count of runs that correspond to the task ID. Returns an integer. 
     * Count the runs corresponding to the task ID.
     */
    async tasksRunsIdCountGet(requestParameters: TasksRunsIdCountGetRequest): Promise<number> {
        const response = await this.tasksRunsIdCountGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * The queue list only contains: * stuff * other junk 
     * Obtain the run list based on the task ID.
     */
    async tasksRunsIdGetRaw(requestParameters: TasksRunsIdGetRequest): Promise<runtime.ApiResponse<Array<Run>>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling tasksRunsIdGet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.perPage !== undefined) {
            queryParameters['perPage'] = requestParameters.perPage;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Cookie"] = this.configuration.apiKey("Cookie"); // session authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // token authentication
        }

        const response = await this.request({
            path: `/tasks/runs/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(RunFromJSON));
    }

    /**
     * The queue list only contains: * stuff * other junk 
     * Obtain the run list based on the task ID.
     */
    async tasksRunsIdGet(requestParameters: TasksRunsIdGetRequest): Promise<Array<Run>> {
        const response = await this.tasksRunsIdGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * This call implements basic pagination over the entire task corpus that intersects with your subscription list. It returns a list of tasks. 
     * Obtain the list of tasks that belong to repositories you are subscribed to.
     */
    async tasksSubscribedGetRaw(requestParameters: TasksSubscribedGetRequest): Promise<runtime.ApiResponse<Array<Task>>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.perPage !== undefined) {
            queryParameters['perPage'] = requestParameters.perPage;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Cookie"] = this.configuration.apiKey("Cookie"); // session authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // token authentication
        }

        const response = await this.request({
            path: `/tasks/subscribed`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TaskFromJSON));
    }

    /**
     * This call implements basic pagination over the entire task corpus that intersects with your subscription list. It returns a list of tasks. 
     * Obtain the list of tasks that belong to repositories you are subscribed to.
     */
    async tasksSubscribedGet(requestParameters: TasksSubscribedGetRequest): Promise<Array<Task>> {
        const response = await this.tasksSubscribedGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * The next GET /token will create a new one. This will just remove it. 
     * Remove and reset your tinyCI access token
     */
    async tokenDeleteRaw(): Promise<runtime.ApiResponse<void>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // token authentication
        }

        const response = await this.request({
            path: `/token`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * The next GET /token will create a new one. This will just remove it. 
     * Remove and reset your tinyCI access token
     */
    async tokenDelete(): Promise<void> {
        await this.tokenDeleteRaw();
    }

    /**
     * This will allow you unfettered access to the system as your user that you request the token with. 
     * Get a tinyCI access token
     */
    async tokenGetRaw(): Promise<runtime.ApiResponse<string>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Cookie"] = this.configuration.apiKey("Cookie"); // session authentication
        }

        const response = await this.request({
            path: `/token`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * This will allow you unfettered access to the system as your user that you request the token with. 
     * Get a tinyCI access token
     */
    async tokenGet(): Promise<string> {
        const response = await this.tokenGetRaw();
        return await response.value();
    }

    /**
     * Get information about the current user, such as the username. 
     * Get information about the current user
     */
    async userPropertiesGetRaw(): Promise<runtime.ApiResponse<void>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Cookie"] = this.configuration.apiKey("Cookie"); // session authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // token authentication
        }

        const response = await this.request({
            path: `/user/properties`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Get information about the current user, such as the username. 
     * Get information about the current user
     */
    async userPropertiesGet(): Promise<void> {
        await this.userPropertiesGetRaw();
    }

}
